"""
2D Bloch Oscillations: Interactive Marimo Viewer
=================================================

Interactive notebook for exploring the 2D numerical C3 moire Bloch oscillation model.
Visualizes differential resistance, carrier dynamics, and C3 symmetry effects.

Author: Generated with Claude Code
"""

import marimo

__generated_with = "0.18.4"
app = marimo.App(width="medium")


@app.cell
def _():
    import marimo as mo
    import numpy as np
    import os
    import plotly.graph_objects as go
    from plotly.subplots import make_subplots
    import plotly.express as px
    return go, make_subplots, mo, np, os, px


@app.function
def load_embedded(key):
    """Load numpy data from embedded base64."""
    import base64 as _b64
    import io as _io
    import zlib as _zlib
    import numpy as _np

    # Data stored as concatenated strings (not dict) to avoid display
    _KEYS = "heatmap_2d_Delta70meV|heatmap_2d_numerical_data|heatmap_2d_Delta60meV|heatmap_2d_Delta50meV|heatmap_bandwidth_sweep_beta05"
    _VALS = "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"

    _k_list = _KEYS.split("|")
    _v_list = _VALS.split("|")

    if key in _k_list:
        idx = _k_list.index(key)
        raw = _zlib.decompress(_b64.b64decode(_v_list[idx]))
        return _np.load(_io.BytesIO(raw))
    return None


@app.cell
def load_data(np, os):
    # Try loading from file first, fall back to embedded data
    if os.path.exists('heatmap_2d_numerical_data.npz'):
        data = np.load('heatmap_2d_numerical_data.npz')
    else:
        data = load_embedded('heatmap_2d_numerical_data')
        if data is None:
            raise FileNotFoundError("Data file not found and no embedded data available")

    # Extract arrays
    beta_values = data['beta_values']
    F_values = data['F_values']
    F_over_Fc = data['F_over_Fc']
    j_grid = data['j_grid']
    heatmap_kV = data['heatmap_kV']
    j_curves = data['j_curves']
    j_max_values = data['j_max_values']

    # Physical parameters
    Delta_meV = float(data['Delta_meV'])
    tau = float(data['tau'])
    a_M = float(data['a_M'])
    F_c = float(data['F_c'])
    n_full = float(data['n_full'])
    g_degeneracy = int(data['g_degeneracy'])
    n_k_data = int(data['n_k'])
    n_time_data = int(data['n_time'])
    return (
        Delta_meV,
        F_c,
        F_over_Fc,
        a_M,
        beta_values,
        g_degeneracy,
        heatmap_kV,
        j_curves,
        j_grid,
        j_max_values,
        n_full,
        tau,
    )


@app.cell
def constants():
    e_charge = 1.602176634e-19   # Electron charge [C]
    hbar = 1.054571817e-34       # Reduced Planck constant [Js]
    return e_charge, hbar


@app.cell
def dispersion_functions(np):
    def moire_dispersion(kx, ky, Delta_eV):
        """C3-symmetric moire band dispersion."""
        G1_dot_k = kx
        G2_dot_k = -0.5 * kx + np.sqrt(3) / 2 * ky
        G3_dot_k = -0.5 * kx - np.sqrt(3) / 2 * ky
        return -(Delta_eV / 3) * (np.cos(G1_dot_k) + np.cos(G2_dot_k) + np.cos(G3_dot_k))

    def moire_velocity_x(kx, ky, Delta_eV):
        """X-component of group velocity (in eV, dimensionless k)."""
        G1_dot_k = kx
        G2_dot_k = -0.5 * kx + np.sqrt(3) / 2 * ky
        G3_dot_k = -0.5 * kx - np.sqrt(3) / 2 * ky
        return (Delta_eV / 3) * (np.sin(G1_dot_k) * 1.0 + np.sin(G2_dot_k) * (-0.5) + np.sin(G3_dot_k) * (-0.5))

    def separable_dispersion(kx, ky, Delta_eV):
        """Separable (square) dispersion for comparison."""
        return -Delta_eV * (np.cos(kx) + np.cos(ky)) / 2
    return moire_dispersion, moire_velocity_x, separable_dispersion


@app.cell
def create_tabs(
    mo,
    tab1_content,
    tab2_content,
    tab3_content,
    tab4_content,
    tab5_content,
    tab6_content,
    tab7_content,
):
    tabs = mo.ui.tabs({
        "Algorithm": tab2_content,
        "Results": tab1_content,
        "BZ Evolution": tab3_content,
        "C3 Symmetry": tab4_content,
        "Parameters": tab5_content,
        "Explorer": tab6_content,
        "Physics Insight": tab7_content,
    })
    return (tabs,)


@app.cell
def display_tabs(mo, tabs):
    mo.vstack([
        mo.md(r"""
    # 2D Bloch Oscillations in C3 Moire Systems

    Interactive exploration of differential resistance and carrier dynamics in a C3-symmetric moire band structure.
        """),
        tabs
    ])
    return


@app.cell
def tab1_results(
    Delta_meV,
    F_c,
    F_over_Fc,
    a_M,
    beta_values,
    go,
    heatmap_kV,
    j_curves,
    j_grid,
    j_max_values,
    mo,
    np,
    px,
    tau,
):

    # Find valid j range (rising part only)
    j_limit = np.max(j_max_values) * 1.1

    # Create heatmap
    fig_heatmap = go.Figure(data=go.Heatmap(
        z=heatmap_kV,
        x=j_grid,
        y=beta_values,
        colorscale='Viridis',
        zmin=0,
        zmax=25,
        colorbar=dict(title='r_diff [kVm/A]')
    ))

    fig_heatmap.update_layout(
        title=f'Differential Resistance r_diff(j, )<br>={Delta_meV:.0f} meV, ={tau*1e12:.0f} ps, a_M={a_M*1e9:.1f} nm, F_c={F_c/1e3:.2f} kV/m',
        xaxis_title='j [A/m]',
        yaxis_title=' (filling fraction)',
        xaxis=dict(range=[0, j_limit]),
        height=500,
        template='plotly_white'
    )

    # Create j(F) curves
    fig_jf = go.Figure()

    colors = px.colors.sample_colorscale('Viridis', [i/(len(beta_values)-1) for i in range(len(beta_values))])

    for i, (_beta_val, _color) in enumerate(zip(beta_values, colors)):
        if i % 4 == 0:  # Show every 4th curve to avoid clutter
            fig_jf.add_trace(go.Scatter(
                x=F_over_Fc,
                y=j_curves[i],
                mode='lines',
                name=f'={_beta_val:.2f}',
                line=dict(color=_color, width=2)
            ))

    fig_jf.add_vline(x=1.0, line_dash="dash", line_color="gray", opacity=0.5)
    fig_jf.add_annotation(x=1.0, y=np.max(j_curves)*0.9, text="F=F_c", showarrow=False)

    fig_jf.update_layout(
        title='Current-Field Characteristics j(F/F_c)',
        xaxis_title='F / F_c',
        yaxis_title='j [A/m]',
        xaxis=dict(range=[0, 3.5]),
        height=400,
        template='plotly_white',
        showlegend=True,
        legend=dict(x=1.02, y=1)
    )

    # =========================================================================
    # LINETRACES: Horizontal cuts (r_diff vs j at fixed )
    # =========================================================================
    fig_linetraces_beta = go.Figure()

    # Select specific  values for linetraces
    beta_indices = [0, len(beta_values)//4, len(beta_values)//2, 3*len(beta_values)//4, len(beta_values)-1]
    linetrace_colors = px.colors.qualitative.Set1

    for _idx, beta_idx in enumerate(beta_indices):
        if beta_idx < len(beta_values):
            _beta = beta_values[beta_idx]
            _rdiff = heatmap_kV[beta_idx, :]
            # Only plot valid (finite) data
            _valid = np.isfinite(_rdiff) & (_rdiff > 0) & (_rdiff < 50)
            fig_linetraces_beta.add_trace(go.Scatter(
                x=j_grid[_valid],
                y=_rdiff[_valid],
                mode='lines',
                name=f' = {_beta:.2f}',
                line=dict(color=linetrace_colors[_idx % len(linetrace_colors)], width=2.5)
            ))

    fig_linetraces_beta.update_layout(
        title='Linetraces: r_diff(j) at Fixed Filling ',
        xaxis_title='j [A/m]',
        yaxis_title='r_diff [kVm/A]',
        xaxis=dict(range=[0, j_limit]),
        yaxis=dict(range=[0, 30]),
        height=400,
        template='plotly_white',
        showlegend=True,
        legend=dict(x=1.02, y=1)
    )

    # =========================================================================
    # LINETRACES: Vertical cuts (r_diff vs  at fixed j)
    # =========================================================================
    fig_linetraces_j = go.Figure()

    # Find j values that give interesting behavior
    j_percentiles = [0.1, 0.3, 0.5, 0.7, 0.9]  # Fraction of j_limit
    j_indices = [int(p * len(j_grid)) for p in j_percentiles]
    j_indices = [min(idx, len(j_grid)-1) for idx in j_indices]  # Clamp

    for _idx, j_idx in enumerate(j_indices):
        _j_val = j_grid[j_idx]
        _rdiff = heatmap_kV[:, j_idx]
        # Only plot valid data
        _valid = np.isfinite(_rdiff) & (_rdiff > 0) & (_rdiff < 50)
        if np.any(_valid):
            fig_linetraces_j.add_trace(go.Scatter(
                x=beta_values[_valid],
                y=_rdiff[_valid],
                mode='lines',
                name=f'j = {_j_val:.1f} A/m',
                line=dict(color=linetrace_colors[_idx % len(linetrace_colors)], width=2.5)
            ))

    fig_linetraces_j.update_layout(
        title='Linetraces: r_diff() at Fixed Current j',
        xaxis_title=' (filling fraction)',
        yaxis_title='r_diff [kVm/A]',
        yaxis=dict(range=[0, 30]),
        height=400,
        template='plotly_white',
        showlegend=True,
        legend=dict(x=1.02, y=1)
    )

    # =========================================================================
    # COMBINED SUBPLOT VIEW
    # =========================================================================
    from plotly.subplots import make_subplots as _make_subplots

    fig_combined_linetraces = _make_subplots(
        rows=1, cols=2,
        subplot_titles=('r_diff(j) at fixed ', 'r_diff() at fixed j'),
        horizontal_spacing=0.12
    )

    # Add  linetraces to left panel
    for _idx, beta_idx in enumerate(beta_indices):
        if beta_idx < len(beta_values):
            _beta = beta_values[beta_idx]
            _rdiff = heatmap_kV[beta_idx, :]
            _valid = np.isfinite(_rdiff) & (_rdiff > 0) & (_rdiff < 50)
            fig_combined_linetraces.add_trace(
                go.Scatter(
                    x=j_grid[_valid],
                    y=_rdiff[_valid],
                    mode='lines',
                    name=f'={_beta:.2f}',
                    line=dict(color=linetrace_colors[_idx % len(linetrace_colors)], width=2),
                    legendgroup='beta',
                    legendgrouptitle_text='Fixed '
                ),
                row=1, col=1
            )

    # Add j linetraces to right panel
    for _idx, j_idx in enumerate(j_indices):
        _j_val = j_grid[j_idx]
        _rdiff = heatmap_kV[:, j_idx]
        _valid = np.isfinite(_rdiff) & (_rdiff > 0) & (_rdiff < 50)
        if np.any(_valid):
            fig_combined_linetraces.add_trace(
                go.Scatter(
                    x=beta_values[_valid],
                    y=_rdiff[_valid],
                    mode='lines',
                    name=f'j={_j_val:.0f}',
                    line=dict(color=linetrace_colors[_idx % len(linetrace_colors)], width=2, dash='dash'),
                    legendgroup='j',
                    legendgrouptitle_text='Fixed j'
                ),
                row=1, col=2
            )

    fig_combined_linetraces.update_xaxes(title_text='j [A/m]', range=[0, j_limit], row=1, col=1)
    fig_combined_linetraces.update_xaxes(title_text='', row=1, col=2)
    fig_combined_linetraces.update_yaxes(title_text='r_diff [kVm/A]', range=[0, 25], row=1, col=1)
    fig_combined_linetraces.update_yaxes(title_text='r_diff [kVm/A]', range=[0, 25], row=1, col=2)

    fig_combined_linetraces.update_layout(
        title='Linetrace Analysis: Cuts Through the r_diff Heatmap',
        height=450,
        template='plotly_white',
        legend=dict(x=1.02, y=1)
    )

    tab1_content = mo.vstack([
        mo.md(r"""
    ## Computed Results

    The heatmap shows differential resistance $r_{\text{diff}} = dF/dj$ as a function of current density $j$ and filling fraction $\beta$.

    **Key features:**
    - Rising branch only (positive $r_{\text{diff}}$)
    - Peak current increases with filling up to $\beta \approx 0.7$
    - Higher $r_{\text{diff}}$ indicates approaching NDR regime
        """),
        fig_heatmap,
        mo.md(r"""
    ### Current-Field Curves

    The current-field characteristics show Bloch oscillation behavior: $j$ rises with $F$ up to a maximum, then shows negative differential resistance (NDR) for $F > F_c$.
        """),
        fig_jf,
        mo.md(r"""
    ---
    ### Linetrace Analysis

    **Horizontal cuts** (left): $r_{\text{diff}}(j)$ at fixed filling $\beta$
    - Shows how differential resistance varies with current at each filling
    - Peak in $r_{\text{diff}}$ marks approaching Bloch oscillation regime
    - Higher $\beta$  larger peak current before NDR onset

    **Vertical cuts** (right): $r_{\text{diff}}(\beta)$ at fixed current $j$
    - Shows filling dependence at constant current bias
    - Reveals optimal filling for maximum/minimum $r_{\text{diff}}$
    - Non-monotonic behavior reflects band structure effects
        """),
        fig_combined_linetraces,
        mo.md(r"""
    ### Individual Linetrace Plots
        """),
        mo.hstack([fig_linetraces_beta, fig_linetraces_j], justify='space-around')
    ])
    return (tab1_content,)


@app.cell
def tab2_algorithm(
    go,
    make_subplots,
    mo,
    moire_dispersion,
    moire_velocity_x,
    np,
    px,
):

    # =========================================================================
    # STEP 1: DISPERSION VISUALIZATION
    # =========================================================================
    _kx = np.linspace(-np.pi, np.pi, 100)
    _ky = np.linspace(-np.pi, np.pi, 100)
    _KX, _KY = np.meshgrid(_kx, _ky)

    _Delta_eV = 0.08  # 80 meV
    _E = moire_dispersion(_KX, _KY, _Delta_eV)

    # 3D surface plot of dispersion
    fig_dispersion_3d = go.Figure(data=[go.Surface(
        x=_kx, y=_ky, z=_E*1000,
        colorscale='Viridis',
        colorbar=dict(title=' [meV]')
    )])
    fig_dispersion_3d.update_layout(
        title='C3-Symmetric Moire Band Dispersion (k)',
        scene=dict(
            xaxis_title='k_x',
            yaxis_title='k_y',
            zaxis_title=' [meV]',
            camera=dict(eye=dict(x=1.5, y=1.5, z=1.0))
        ),
        height=450,
        template='plotly_white'
    )

    # Contour plot with high-symmetry points marked
    fig_dispersion_contour = go.Figure()
    fig_dispersion_contour.add_trace(go.Contour(
        x=_kx, y=_ky, z=_E*1000,
        colorscale='Viridis',
        colorbar=dict(title=' [meV]'),
        contours=dict(showlabels=True, labelfont=dict(size=10))
    ))
    # Mark high-symmetry points
    _hs_points = {'': (0, 0), 'M': (np.pi, 0), 'M\'': (0, np.pi)}
    for _name, (_px, _py) in _hs_points.items():
        fig_dispersion_contour.add_trace(go.Scatter(
            x=[_px], y=[_py], mode='markers+text',
            marker=dict(size=12, color='red', symbol='x'),
            text=[_name], textposition='top center',
            textfont=dict(size=14, color='red'),
            showlegend=False
        ))
    fig_dispersion_contour.update_layout(
        title='Dispersion Contours with High-Symmetry Points',
        xaxis_title='k_x', yaxis_title='k_y',
        height=400, template='plotly_white'
    )

    # =========================================================================
    # STEP 2: VELOCITY FIELD VISUALIZATION
    # =========================================================================
    _Vx = moire_velocity_x(_KX, _KY, _Delta_eV)

    # Also compute Vy for the full velocity field
    def _moire_velocity_y(_kx, _ky, _Delta):
        G1_dot_k = _kx
        G2_dot_k = -0.5*_kx + np.sqrt(3)/2*_ky
        G3_dot_k = -0.5*_kx - np.sqrt(3)/2*_ky
        return (_Delta/3) * (np.sin(G1_dot_k)*0 + np.sin(G2_dot_k)*(np.sqrt(3)/2) + np.sin(G3_dot_k)*(-np.sqrt(3)/2))

    _Vy = _moire_velocity_y(_KX, _KY, _Delta_eV)
    _V_mag = np.sqrt(_Vx**2 + _Vy**2)

    # Velocity components side by side
    fig_vel_components = make_subplots(rows=1, cols=2,
        subplot_titles=['v_x(k) = /k_x', 'v_y(k) = /k_y'])
    fig_vel_components.add_trace(go.Heatmap(
        x=_kx, y=_ky, z=_Vx*1000, colorscale='RdBu', zmid=0,
        colorbar=dict(title='v_x [meV]', x=0.45)
    ), row=1, col=1)
    fig_vel_components.add_trace(go.Heatmap(
        x=_kx, y=_ky, z=_Vy*1000, colorscale='RdBu', zmid=0,
        colorbar=dict(title='v_y [meV]', x=1.02)
    ), row=1, col=2)
    fig_vel_components.update_layout(height=350, template='plotly_white')
    fig_vel_components.update_xaxes(title_text='k_x')
    fig_vel_components.update_yaxes(title_text='k_y')

    # =========================================================================
    # STEP 3: FERMI SURFACE VS FILLING
    # =========================================================================
    _epsilon_min = -_Delta_eV
    _epsilon_max = _Delta_eV / 2

    fig_fermi_filling = go.Figure()
    # Background dispersion
    fig_fermi_filling.add_trace(go.Contour(
        x=_kx, y=_ky, z=_E*1000,
        colorscale='Greys', opacity=0.3, showscale=False
    ))
    # Fermi surfaces at different fillings
    _betas = [0.1, 0.3, 0.5, 0.7, 0.9]
    _colors = px.colors.sample_colorscale('Viridis', [b for b in _betas])
    for _beta, _color in zip(_betas, _colors):
        _eps_F = _epsilon_min + _beta * (_epsilon_max - _epsilon_min)
        fig_fermi_filling.add_trace(go.Contour(
            x=_kx, y=_ky, z=_E,
            contours=dict(start=_eps_F, end=_eps_F, size=0.0001, coloring='lines'),
            line=dict(color=_color, width=3),
            showscale=False, name=f'={_beta}'
        ))
    fig_fermi_filling.update_layout(
        title='Fermi Contours at Different Fillings ',
        xaxis_title='k_x', yaxis_title='k_y',
        height=450, template='plotly_white',
        showlegend=True, legend=dict(x=1.02)
    )

    # DOS plot
    _E_flat = _E.flatten()
    _E_bins = np.linspace(_epsilon_min*1000, _epsilon_max*1000, 100)
    _dos, _bin_edges = np.histogram(_E_flat*1000, bins=_E_bins, density=True)
    _E_centers = (_bin_edges[:-1] + _bin_edges[1:]) / 2

    fig_dos = go.Figure()
    fig_dos.add_trace(go.Scatter(
        x=_dos, y=_E_centers, mode='lines', fill='tozerox',
        line=dict(color='blue', width=2), name='DOS'
    ))
    # Mark Fermi levels
    for _beta, _color in zip(_betas, _colors):
        _eps_F = (_epsilon_min + _beta * (_epsilon_max - _epsilon_min)) * 1000
        fig_dos.add_hline(y=_eps_F, line_dash='dash', line_color=_color,
                         annotation_text=f'={_beta}', annotation_position='right')
    fig_dos.update_layout(
        title='Density of States',
        xaxis_title='DOS [a.u.]', yaxis_title=' [meV]',
        height=400, template='plotly_white'
    )

    # =========================================================================
    # STEP 4: TRAJECTORY AVERAGING VISUALIZATION
    # =========================================================================
    # Show trajectory in k-space with exponential weighting
    _omega_B = 0.5  # Bloch frequency
    _tau_demo = 3.0
    _t_traj = np.linspace(0, 5*_tau_demo, 100)
    _weights_traj = np.exp(-_t_traj / _tau_demo)

    # Starting point
    _k0x, _k0y = 1.5, 0.8
    _kx_traj = _k0x - _omega_B * _t_traj
    # Wrap to BZ
    _kx_traj_wrapped = ((_kx_traj + np.pi) % (2*np.pi)) - np.pi

    fig_trajectory = go.Figure()
    # Background: dispersion
    fig_trajectory.add_trace(go.Contour(
        x=_kx, y=_ky, z=_E*1000,
        colorscale='Viridis', opacity=0.6,
        colorbar=dict(title=' [meV]', x=1.15),
        contours=dict(showlabels=True)
    ))
    # Trajectory colored by weight
    fig_trajectory.add_trace(go.Scatter(
        x=_kx_traj_wrapped, y=np.full_like(_kx_traj_wrapped, _k0y),
        mode='markers',
        marker=dict(size=8, color=_weights_traj, colorscale='Reds',
                   showscale=True, colorbar=dict(title='e^(-t/)', x=1.3)),
        name='Backward trajectory'
    ))
    # Starting point
    fig_trajectory.add_trace(go.Scatter(
        x=[_k0x], y=[_k0y], mode='markers',
        marker=dict(size=15, color='black', symbol='star'),
        name='Current k-point'
    ))
    # Arrow showing field direction
    fig_trajectory.add_annotation(
        x=_k0x, y=_k0y + 0.3, ax=_k0x - 0.8, ay=_k0y + 0.3,
        xref='x', yref='y', axref='x', ayref='y',
        showarrow=True, arrowhead=2, arrowsize=1.5, arrowwidth=2, arrowcolor='red'
    )
    fig_trajectory.add_annotation(
        x=_k0x - 0.4, y=_k0y + 0.5, text='F direction', showarrow=False,
        font=dict(color='red', size=12)
    )
    fig_trajectory.update_layout(
        title='Trajectory Averaging: Trace Backward Along k(t) = k - eFt/',
        xaxis_title='k_x', yaxis_title='k_y',
        height=450, template='plotly_white'
    )

    # Exponential weighting visualization
    fig_weights = make_subplots(rows=1, cols=2,
        subplot_titles=['Exponential Memory Kernel', 'Cumulative Weight'])
    fig_weights.add_trace(go.Scatter(
        x=_t_traj/_tau_demo, y=_weights_traj,
        mode='lines', line=dict(color='blue', width=3),
        name='e^(-t/)', fill='tozeroy'
    ), row=1, col=1)
    fig_weights.add_vline(x=1, line_dash='dash', row=1, col=1)

    _cumulative = 1 - np.exp(-_t_traj/_tau_demo)
    fig_weights.add_trace(go.Scatter(
        x=_t_traj/_tau_demo, y=_cumulative,
        mode='lines', line=dict(color='green', width=3),
        name=' e^(-s/) ds/'
    ), row=1, col=2)
    fig_weights.add_hline(y=0.632, line_dash='dash', row=1, col=2)
    fig_weights.add_hline(y=0.95, line_dash='dot', row=1, col=2)
    fig_weights.update_xaxes(title_text='t / ')
    fig_weights.update_yaxes(title_text='Weight', row=1, col=1)
    fig_weights.update_yaxes(title_text='Cumulative', row=1, col=2)
    fig_weights.update_layout(height=350, template='plotly_white', showlegend=False)

    # =========================================================================
    # STEP 5: FIELD DIRECTION DEPENDENCE (C3 SYMMETRY!)
    # =========================================================================
    # Show that current depends on field direction for C3 lattice
    _n_angles = 72
    _angles = np.linspace(0, 2*np.pi, _n_angles, endpoint=False)

    # For a fixed field magnitude, compute current for different field directions
    _beta_demo = 0.5
    _eps_F_demo = _epsilon_min + _beta_demo * (_epsilon_max - _epsilon_min)
    _occupied = _E < _eps_F_demo

    # For C3 symmetry, show the angular dependence
    _j_magnitude = []
    for _theta in _angles:
        # Project velocity onto field direction
        _v_parallel = _Vx * np.cos(_theta) + _Vy * np.sin(_theta)
        _j_theta = np.mean(_v_parallel[_occupied])
        _j_magnitude.append(abs(_j_theta))

    # Normalize
    _j_magnitude = np.array(_j_magnitude)
    _j_magnitude = _j_magnitude / np.max(_j_magnitude)

    fig_field_direction = go.Figure()
    # Polar plot
    fig_field_direction.add_trace(go.Scatterpolar(
        r=np.append(_j_magnitude, _j_magnitude[0]),  # Close the loop
        theta=np.degrees(np.append(_angles, _angles[0])),
        mode='lines',
        line=dict(color='blue', width=3),
        fill='toself', fillcolor='rgba(0,0,255,0.2)',
        name='|j| vs field direction'
    ))
    fig_field_direction.update_layout(
        title='Current Magnitude vs Field Direction (=0.5)',
        polar=dict(
            radialaxis=dict(visible=True, title='|j| [norm.]'),
            angularaxis=dict(direction='counterclockwise', rotation=90)
        ),
        height=450, template='plotly_white'
    )

    # =========================================================================
    # STEP 6: CURRENT INTEGRATION VISUALIZATION
    # =========================================================================
    # Show the integrand v_x(k) * g(k)
    fig_integrand = make_subplots(rows=1, cols=3,
        subplot_titles=['Occupation g(k)', 'Velocity v_x(k)', 'Integrand v_xg'])

    # Simplified: show equilibrium occupation
    _g_eq = (_E < _eps_F_demo).astype(float)
    fig_integrand.add_trace(go.Heatmap(
        x=_kx, y=_ky, z=_g_eq, colorscale='Blues',
        showscale=False
    ), row=1, col=1)
    fig_integrand.add_trace(go.Heatmap(
        x=_kx, y=_ky, z=_Vx*1000, colorscale='RdBu', zmid=0,
        showscale=False
    ), row=1, col=2)
    fig_integrand.add_trace(go.Heatmap(
        x=_kx, y=_ky, z=_Vx*_g_eq*1000, colorscale='RdBu', zmid=0,
        colorbar=dict(title='v_xg')
    ), row=1, col=3)
    fig_integrand.update_layout(height=300, template='plotly_white')
    fig_integrand.update_xaxes(title_text='k_x')
    fig_integrand.update_yaxes(title_text='k_y')

    # =========================================================================
    # ASSEMBLE TAB CONTENT
    # =========================================================================
    tab2_content = mo.vstack([
        mo.md(r"""
    # Numerical Algorithm: Detailed Step-by-Step Guide

    This tab provides a comprehensive explanation of the 2D Bloch oscillation current calculation using trajectory averaging in the relaxation-time approximation.

    ---

    ## Step 1: Define the C3-Symmetric Moire Dispersion

    ### Physical Origin

    In twisted bilayer graphene (TBG) and similar moire systems, the effective band structure has **C3 (threefold) rotational symmetry** inherited from the hexagonal lattice. The simplest tight-binding model gives:

    $$
    \varepsilon(\mathbf{k}) = -\frac{\Delta}{3}\left[\cos(\mathbf{G}_1 \cdot \mathbf{k}) + \cos(\mathbf{G}_2 \cdot \mathbf{k}) + \cos(\mathbf{G}_3 \cdot \mathbf{k})\right]
    $$

    where the **moire reciprocal lattice vectors** are separated by 120:

    | Vector | Components | Physical Meaning |
    |--------|-----------|------------------|
    | $\mathbf{G}_1$ | $(1, 0)$ | Along x-axis |
    | $\mathbf{G}_2$ | $(-\frac{1}{2}, \frac{\sqrt{3}}{2})$ | Rotated +120 |
    | $\mathbf{G}_3$ | $(-\frac{1}{2}, -\frac{\sqrt{3}}{2})$ | Rotated -120 |

    ### Key Properties

    - **Bandwidth**: $W = \frac{3\Delta}{2}$ (from minimum at  to maximum at K-points)
    - **Minimum**: $\varepsilon_{\min} = -\Delta$ at $\Gamma = (0, 0)$
    - **Maximum**: $\varepsilon_{\max} = +\Delta/2$ at the K-points
    - **Van Hove singularities**: At M-points (saddle points in dispersion)
        """),
        fig_dispersion_3d,
        fig_dispersion_contour,
        mo.md(r"""
    ---

    ## Step 2: Compute the Group Velocity Field

    ### Derivation

    The group velocity is the gradient of the dispersion:

    $$
    \mathbf{v}(\mathbf{k}) = \frac{1}{\hbar}\nabla_\mathbf{k}\varepsilon(\mathbf{k})
    $$

    For our C3 dispersion, the components are:

    $$
    v_x = \frac{\Delta}{3\hbar}\left[\sin(\mathbf{G}_1 \cdot \mathbf{k}) \cdot 1 + \sin(\mathbf{G}_2 \cdot \mathbf{k}) \cdot (-\tfrac{1}{2}) + \sin(\mathbf{G}_3 \cdot \mathbf{k}) \cdot (-\tfrac{1}{2})\right]
    $$

    $$
    v_y = \frac{\Delta}{3\hbar}\left[\sin(\mathbf{G}_2 \cdot \mathbf{k}) \cdot \tfrac{\sqrt{3}}{2} + \sin(\mathbf{G}_3 \cdot \mathbf{k}) \cdot (-\tfrac{\sqrt{3}}{2})\right]
    $$

    ### Physical Insight

    - **Maximum velocity**: $v_{\max} = \frac{\Delta \cdot a_M}{2\hbar}$ (occurs at inflection points)
    - **Zero velocity**: At band extrema ( and K points)
    - **C3 symmetry**: The velocity field rotates by 120 under C3 rotation
        """),
        fig_vel_components,
        mo.md(r"""
    ---

    ## Step 3: Determine Fermi Energy from Filling Fraction

    ### Energy-Filling Relationship

    The **filling fraction** $\beta \in [0, 1]$ represents what fraction of the band is occupied:

    $$
    \beta = \frac{1}{A_{BZ}} \iint_{BZ} \Theta(\varepsilon_F - \varepsilon(\mathbf{k})) \, d^2k
    $$

    For computational simplicity, we use a linear interpolation:

    $$
    \varepsilon_F(\beta) = \varepsilon_{\min} + \beta \cdot (\varepsilon_{\max} - \varepsilon_{\min})
    $$

    ### Fermi Surface Evolution

    As  increases:
    - **  0**: Small pocket around  (electron-like)
    - **  0.5**: Large, trigonally-warped contour
    - **  1**: Small pockets around K-points (hole-like)

    The **trigonal warping** is a direct consequence of C3 symmetry!
        """),
        mo.hstack([fig_fermi_filling, fig_dos]),
        mo.md(r"""
    ---

    ## Step 4: Trajectory Averaging  The Heart of the Algorithm

    ### Physical Motivation: Why Trajectory Averaging?

    The Boltzmann transport equation in the **relaxation-time approximation** is:

    $$
    \frac{\partial f}{\partial t} + \frac{e\mathbf{F}}{\hbar} \cdot \nabla_\mathbf{k} f = -\frac{f - f_0}{\tau}
    $$

    where:
    - $f(\mathbf{k}, t)$ = non-equilibrium distribution function
    - $f_0(\mathbf{k})$ = equilibrium Fermi-Dirac distribution
    - $\tau$ = momentum relaxation time
    - $\mathbf{F}$ = electric field

    ### Steady-State Solution

    In steady state ($\partial f/\partial t = 0$), the solution can be written as a **trajectory integral**:

    $$
    \boxed{g(\mathbf{k}) = \int_0^\infty f_0\left(\varepsilon(\mathbf{k} - \frac{e\mathbf{F}t}{\hbar})\right) \cdot \frac{e^{-t/\tau}}{\tau} \, dt}
    $$

    ### Physical Interpretation

    This formula has a beautiful interpretation:

    1. **Trace backward**: From current k-point, trace the electron's trajectory backward in time
    2. **Sample equilibrium**: At each past time, the electron "remembers" the equilibrium distribution
    3. **Exponential memory**: Recent times (small t) matter more due to $e^{-t/\tau}$ weighting
    4. **Scattering resets**: After time $\sim\tau$, the electron has likely scattered and lost its history
        """),
        fig_trajectory,
        fig_weights,
        mo.md(r"""
    ### Why This Approach vs. Other Methods?

    | Method | Pros | Cons |
    |--------|------|------|
    | **Trajectory averaging** | Exact for RTA, handles Bloch oscillations naturally | Requires numerical integration |
    | **Linear response** | Simple analytical formulas | Fails for $F > F_c$ (NDR regime) |
    | **Full Boltzmann** | Most general | Computationally expensive |
    | **Drude model** | Very simple | No band structure effects |

    **For Bloch oscillations**, trajectory averaging is essential because:
    - It captures the **periodic k-space motion** naturally
    - It correctly describes the **negative differential resistance** (NDR) regime
    - It smoothly interpolates between weak-field (Ohmic) and strong-field (Bloch) limits

    ### The Bloch Frequency

    The key parameter is the **Bloch frequency**:

    $$
    \omega_B = \frac{eF a_M}{\hbar}
    $$

    This is the rate at which electrons traverse the Brillouin zone. The physics depends on $\omega_B \tau$:

    | Regime | Condition | Physics |
    |--------|-----------|---------|
    | Ohmic | $\omega_B \tau \ll 1$ | Electrons scatter before completing oscillation |
    | Critical | $\omega_B \tau \sim 1$ | Maximum current, onset of NDR |
    | Bloch | $\omega_B \tau \gg 1$ | Coherent oscillations, current decreases |

    ---

    ## Step 5: Does Field Direction Matter? YES for C3 Symmetry!

    ### The Key Insight

    For a **separable** (square) dispersion like $\varepsilon = -\Delta(\cos k_x + \cos k_y)/2$:
    - Current in x-direction depends only on $F_x$
    - Current in y-direction depends only on $F_y$
    - Field direction doesn't affect the magnitude of j along F

    For **C3-symmetric** dispersion:
    - The Fermi surface has trigonal warping
    - Different field directions "see" different effective band structures
    - The j(F) curve depends on field orientation!
        """),
        fig_field_direction,
        mo.md(r"""
    ### Mathematical Reason

    The current is:

    $$
    j_\parallel = \int v_\parallel(\mathbf{k}) \cdot g(\mathbf{k}) \, d^2k
    $$

    where $v_\parallel = \mathbf{v} \cdot \hat{\mathbf{F}}$ is the velocity component along the field.

    For C3 symmetry:
    - The distribution $g(\mathbf{k})$ depends on field direction
    - The projection $v_\parallel(\mathbf{k})$ also depends on field direction
    - The combination produces a **6-fold symmetric** response (C3  inversion)

    ### Practical Implication

    For **isotropic average** (polycrystalline sample or thermal averaging):
    - Average over all field directions
    - The 6-fold modulation averages out
    - Effective response is isotropic

    For **single-domain** sample:
    - Anisotropic transport possible
    - Maximum current along specific crystallographic directions
    - Useful for probing lattice symmetry

    ---

    ## Step 6: Current Integration Over the Brillouin Zone

    ### The Current Formula

    The steady-state current density is:

    $$
    \mathbf{j} = \frac{g_s g_v e}{(2\pi)^2} \iint_{BZ} \mathbf{v}(\mathbf{k}) \cdot g(\mathbf{k}) \, d^2k
    $$

    where:
    - $g_s = 2$ (spin degeneracy)
    - $g_v$ = valley degeneracy (4 for TBG)
    - $g(\mathbf{k})$ = trajectory-averaged occupation

    ### Visualization of the Integrand

    The integrand $v_x(\mathbf{k}) \cdot g(\mathbf{k})$ shows where current contributions come from:
        """),
        fig_integrand,
        mo.md(r"""
    ### Key Observations

    1. **Occupation g(k)**: Filled states (blue) inside the Fermi contour
    2. **Velocity v_x(k)**: Alternating positive/negative regions (red/blue)
    3. **Integrand v_xg**: Only occupied states contribute; note the partial cancellation!

    The **net current** comes from the imbalance between positive and negative velocity contributions within the occupied region.

    ---

    ## Step 7: Differential Resistance

    ### Definition

    The **differential resistance** is the slope of the F-j curve:

    $$
    r_{\text{diff}} = \frac{dF}{dj}
    $$

    ### Physical Meaning

    | $r_{\text{diff}}$ | Meaning |
    |------------------|---------|
    | $> 0$ | Normal (positive) resistance |
    | $= \infty$ | Peak current (j at maximum) |
    | $< 0$ | Negative differential resistance (NDR) |

    ### Stability Note

    We only show the **rising branch** (positive $r_{\text{diff}}$) because:
    1. The falling branch is unstable to domain formation
    2. Experimentally, the system typically jumps to high-field state
    3. The rising branch is what's measured in stable DC transport

    ---

    ## Summary: The Complete Algorithm

    ```
    1. INPUT:  (filling), F_values (field sweep), physical parameters
    2. FOR each F in F_values:
       a. Compute _B = eFa_M/
       b. FOR each k in BZ:
      i.  Trace trajectory backward: k(t) = k - _Btx
      ii. Compute g(k) =  f((k(t))) e^(-t/) dt/
       c. Integrate: j =  v_x(k)g(k) dk
    3. OUTPUT: j(F) curve
    4. COMPUTE: r_diff = dF/dj on rising branch
    ```
        """)
    ])
    return (tab2_content,)


@app.cell
def tab3_bz_evolution(go, mo, moire_dispersion, moire_velocity_x, np):

    # Create k-space grid
    _n_k = 100
    _kx = np.linspace(-np.pi, np.pi, _n_k)
    _ky = np.linspace(-np.pi, np.pi, _n_k)
    _KX, _KY = np.meshgrid(_kx, _ky)

    _Delta_eV = 0.08
    _E = moire_dispersion(_KX, _KY, _Delta_eV)
    _Vx = moire_velocity_x(_KX, _KY, _Delta_eV)

    # Fermi contours at different beta
    _epsilon_min = -_Delta_eV
    _epsilon_max = _Delta_eV / 2

    _beta_demo = [0.2, 0.4, 0.6, 0.8]
    _colors_beta = ['blue', 'green', 'orange', 'red']

    # Figure 1: Fermi contours
    fig_fermi = go.Figure()

    # Add dispersion as background
    fig_fermi.add_trace(go.Contour(
        z=_E*1000,
        x=_kx,
        y=_ky,
        colorscale='Greys',
        opacity=0.3,
        showscale=False,
        contours=dict(coloring='heatmap')
    ))

    # Add Fermi contours
    for _beta, _color in zip(_beta_demo, _colors_beta):
        _eps_F = _epsilon_min + _beta * (_epsilon_max - _epsilon_min)
        fig_fermi.add_trace(go.Contour(
            z=_E,
            x=_kx,
            y=_ky,
            contours=dict(
                start=_eps_F,
                end=_eps_F,
                size=0.001,
                coloring='lines'
            ),
            line=dict(color=_color, width=3),
            showscale=False,
            name=f'={_beta}'
        ))

    fig_fermi.update_layout(
        title='Fermi Contours at Different Fillings',
        xaxis_title='k_x',
        yaxis_title='k_y',
        height=450,
        template='plotly_white',
        showlegend=True
    )

    # Figure 2: Trajectory in k-space
    fig_traj = go.Figure()

    # Starting points on Fermi surface for beta=0.5
    _beta_traj = 0.5
    _eps_F_traj = _epsilon_min + _beta_traj * (_epsilon_max - _epsilon_min)

    # Add dispersion background
    fig_traj.add_trace(go.Contour(
        z=_E*1000,
        x=_kx,
        y=_ky,
        colorscale='Viridis',
        showscale=True,
        colorbar=dict(title=' [meV]'),
        opacity=0.7
    ))

    # Show trajectory for one k-point
    omega_B = 0.3  # Arbitrary Bloch frequency for visualization
    tau_vis = 2.0
    t_traj = np.linspace(0, 4*tau_vis, 50)

    kx0, ky0 = 0.5, 0.8  # Starting point
    kx_traj = kx0 - omega_B * t_traj
    kx_traj_wrapped = ((kx_traj + np.pi) % (2*np.pi)) - np.pi

    # Color by time (exponential weighting)
    weights = np.exp(-t_traj / tau_vis)

    fig_traj.add_trace(go.Scatter(
        x=kx_traj_wrapped,
        y=np.full_like(kx_traj_wrapped, ky0),
        mode='markers',
        marker=dict(
            size=10,
            color=weights,
            colorscale='Reds',
            showscale=True,
            colorbar=dict(title='exp(-t/)', x=1.15)
        ),
        name='Trajectory'
    ))

    # Mark starting point
    fig_traj.add_trace(go.Scatter(
        x=[kx0],
        y=[ky0],
        mode='markers',
        marker=dict(size=15, color='black', symbol='star'),
        name='Start (k)'
    ))

    fig_traj.update_layout(
        title='k-Space Trajectory Under Electric Field',
        xaxis_title='k_x',
        yaxis_title='k_y',
        height=450,
        template='plotly_white'
    )

    # Figure 3: Velocity field
    _n_arrow = 15
    _kx_arrow = np.linspace(-np.pi*0.9, np.pi*0.9, _n_arrow)
    _ky_arrow = np.linspace(-np.pi*0.9, np.pi*0.9, _n_arrow)
    _KXa, _KYa = np.meshgrid(_kx_arrow, _ky_arrow)

    _Vx_arrow = moire_velocity_x(_KXa, _KYa, _Delta_eV)

    # Normalize for visualization
    _V_mag = np.abs(_Vx_arrow)
    _V_max = np.max(_V_mag)

    fig_vel = go.Figure()

    # Add velocity as heatmap
    fig_vel.add_trace(go.Heatmap(
        z=_Vx*1000,
        x=_kx,
        y=_ky,
        colorscale='RdBu',
        zmid=0,
        colorbar=dict(title='v_x [meV]')
    ))

    fig_vel.update_layout(
        title='Velocity Field v_x(k)',
        xaxis_title='k_x',
        yaxis_title='k_y',
        height=450,
        template='plotly_white'
    )

    tab3_content = mo.vstack([
        mo.md(r"""
    ## Carrier Evolution in 2D Brillouin Zone

    This tab visualizes how carriers evolve under an electric field in the 2D k-space.

    ### Key Insight: 2D vs 1D

    **In 1D:** A single k-point slides along the BZ under the field.

    **In 2D:** The *entire Fermi contour* responds. Different k-points have different velocities, leading to phase-space averaging effects.

    ---

    ### Fermi Contours at Different Fillings

    The Fermi contour shows which k-states are occupied. Note the **trigonal warping** from C3 symmetry!
        """),
        fig_fermi,
        mo.md(r"""
    ---

    ### k-Space Trajectory Under Electric Field

    Under field $\mathbf{F}$, each k-point follows:
    $$
    \mathbf{k}(t) = \mathbf{k}_0 + \frac{e\mathbf{F}t}{\hbar}
    $$

    The trajectory wraps around the BZ periodically. The exponential weighting $e^{-t/\tau}$ gives more weight to recent times.
        """),
        fig_traj,
        mo.md(r"""
    ---

    ### Velocity Field v_x(k)

    The current depends on the velocity-weighted integral over the BZ. Notice:
    - v_x changes sign across the BZ
    - C3 symmetry is visible in the pattern
    - Occupied states with opposite v_x partially cancel!
        """),
        fig_vel
    ])
    return (tab3_content,)


@app.cell
def tab4_c3_symmetry(
    go,
    make_subplots,
    mo,
    moire_dispersion,
    moire_velocity_x,
    np,
    separable_dispersion,
):

    _n_k = 100
    _kx = np.linspace(-np.pi, np.pi, _n_k)
    _ky = np.linspace(-np.pi, np.pi, _n_k)
    _KX, _KY = np.meshgrid(_kx, _ky)

    _Delta_eV = 0.08

    _E_c3 = moire_dispersion(_KX, _KY, _Delta_eV)
    _E_sep = separable_dispersion(_KX, _KY, _Delta_eV)

    # Compare dispersions
    fig_compare = make_subplots(rows=1, cols=2,
                                 subplot_titles=['C3 Moire Dispersion', 'Separable (Square) Dispersion'])

    fig_compare.add_trace(go.Contour(
        z=_E_c3*1000,
        x=_kx,
        y=_ky,
        colorscale='Viridis',
        colorbar=dict(title=' [meV]', x=0.45),
        contours=dict(showlabels=True, labelfont=dict(size=10))
    ), row=1, col=1)

    fig_compare.add_trace(go.Contour(
        z=_E_sep*1000,
        x=_kx,
        y=_ky,
        colorscale='Viridis',
        colorbar=dict(title=' [meV]', x=1.02),
        contours=dict(showlabels=True, labelfont=dict(size=10))
    ), row=1, col=2)

    fig_compare.update_layout(height=400, template='plotly_white')
    fig_compare.update_xaxes(title_text='k_x')
    fig_compare.update_yaxes(title_text='k_y')

    # Compare Fermi surfaces
    fig_fermi_compare = make_subplots(rows=1, cols=2,
                                       subplot_titles=['C3: Trigonal Warping', 'Separable: Square/Circular'])

    _beta_demo = 0.5
    _eps_min_c3 = -_Delta_eV
    _eps_max_c3 = _Delta_eV / 2
    _eps_F_c3 = _eps_min_c3 + _beta_demo * (_eps_max_c3 - _eps_min_c3)

    _eps_min_sep = -_Delta_eV
    _eps_max_sep = _Delta_eV
    _eps_F_sep = _eps_min_sep + _beta_demo * (_eps_max_sep - _eps_min_sep)

    # C3 Fermi surface
    fig_fermi_compare.add_trace(go.Contour(
        z=_E_c3,
        x=_kx,
        y=_ky,
        contours=dict(start=_eps_F_c3, end=_eps_F_c3, size=0.001, coloring='lines'),
        line=dict(color='red', width=4),
        showscale=False
    ), row=1, col=1)

    # Separable Fermi surface
    fig_fermi_compare.add_trace(go.Contour(
        z=_E_sep,
        x=_kx,
        y=_ky,
        contours=dict(start=_eps_F_sep, end=_eps_F_sep, size=0.001, coloring='lines'),
        line=dict(color='blue', width=4),
        showscale=False
    ), row=1, col=2)

    fig_fermi_compare.update_layout(height=400, template='plotly_white')
    fig_fermi_compare.update_xaxes(title_text='k_x')
    fig_fermi_compare.update_yaxes(title_text='k_y')

    # Velocity comparison
    _Vx_c3 = moire_velocity_x(_KX, _KY, _Delta_eV)
    _Vx_sep = _Delta_eV * np.sin(_KX) / 2  # For separable

    fig_vel_compare = make_subplots(rows=1, cols=2,
                                     subplot_titles=['C3 Velocity v_x(k)', 'Separable Velocity v_x(k)'])

    fig_vel_compare.add_trace(go.Heatmap(
        z=_Vx_c3*1000,
        x=_kx,
        y=_ky,
        colorscale='RdBu',
        zmid=0,
        colorbar=dict(title='v_x [meV]', x=0.45)
    ), row=1, col=1)

    fig_vel_compare.add_trace(go.Heatmap(
        z=_Vx_sep*1000,
        x=_kx,
        y=_ky,
        colorscale='RdBu',
        zmid=0,
        colorbar=dict(title='v_x [meV]', x=1.02)
    ), row=1, col=2)

    fig_vel_compare.update_layout(height=400, template='plotly_white')
    fig_vel_compare.update_xaxes(title_text='k_x')
    fig_vel_compare.update_yaxes(title_text='k_y')

    tab4_content = mo.vstack([
        mo.md(r"""
    ## C3 Symmetry Effects

    This tab explores how the **C3 (threefold) rotational symmetry** of the moire lattice affects transport.

    ---

    ### C3 vs Separable Dispersion

    **C3 Moire:**
    $$
    \varepsilon(\mathbf{k}) = -\frac{\Delta}{3}\left[\cos(\mathbf{G}_1 \cdot \mathbf{k}) + \cos(\mathbf{G}_2 \cdot \mathbf{k}) + \cos(\mathbf{G}_3 \cdot \mathbf{k})\right]
    $$

    **Separable (Square):**
    $$
    \varepsilon(\mathbf{k}) = -\frac{\Delta}{2}\left[\cos(k_x) + \cos(k_y)\right]
    $$
        """),
        fig_compare,
        mo.md(r"""
    ---

    ### Fermi Surface Shapes

    The C3 symmetry creates **trigonal warping** of the Fermi surface, while the separable dispersion gives more circular/square contours.
        """),
        fig_fermi_compare,
        mo.md(r"""
    ---

    ### Velocity Fields

    The velocity pattern shows the underlying lattice symmetry:
    - **C3:** Three-fold pattern with more complex structure
    - **Separable:** Simple sinusoidal pattern in k_x

    This affects how currents from different k-states combine!
        """),
        fig_vel_compare,
        mo.md(r"""
    ---

    ### Why 2D Reduces Current

    In 2D with C3 symmetry:
    1. **Phase space cancellation:** States with opposite v_x partially cancel
    2. **Trigonal warping:** Non-circular Fermi surfaces lead to different weighting
    3. **Result:** $j_{2D} < j_{1D}$ for same filling

    The ratio $j_{2D}/j_{1D}$ depends on filling  and is typically 0.6-0.9.
        """)
    ])
    return (tab4_content,)


@app.cell
def tab5_parameters(
    Delta_meV,
    F_c,
    a_M,
    e_charge,
    g_degeneracy,
    go,
    hbar,
    mo,
    n_full,
    np,
    tau,
):

    # Calculate derived quantities
    v_max = Delta_meV * 1e-3 * e_charge * a_M / (2 * hbar)  # m/s
    T_B = 2 * np.pi * hbar / (e_charge * F_c * a_M)  # Bloch period at F_c

    # Create scaling plot: F_c vs tau
    tau_range = np.logspace(-13, -11, 50)  # 0.1 ps to 10 ps
    F_c_range = hbar / (e_charge * a_M * tau_range)

    fig_Fc_tau = go.Figure()
    fig_Fc_tau.add_trace(go.Scatter(
        x=tau_range * 1e12,
        y=F_c_range / 1e3,
        mode='lines',
        line=dict(width=3, color='blue'),
        name='F_c()'
    ))
    fig_Fc_tau.add_trace(go.Scatter(
        x=[tau * 1e12],
        y=[F_c / 1e3],
        mode='markers',
        marker=dict(size=15, color='red', symbol='star'),
        name='Current parameters'
    ))

    fig_Fc_tau.update_layout(
        title='Critical Field vs Scattering Time',
        xaxis_title=' [ps]',
        yaxis_title='F_c [kV/m]',
        xaxis_type='log',
        yaxis_type='log',
        height=350,
        template='plotly_white'
    )

    # v_max vs Delta
    Delta_range = np.linspace(10, 200, 50)  # meV
    v_max_range = Delta_range * 1e-3 * e_charge * a_M / (2 * hbar)

    fig_vmax = go.Figure()
    fig_vmax.add_trace(go.Scatter(
        x=Delta_range,
        y=v_max_range,
        mode='lines',
        line=dict(width=3, color='green'),
        name='v_max()'
    ))
    fig_vmax.add_trace(go.Scatter(
        x=[Delta_meV],
        y=[v_max],
        mode='markers',
        marker=dict(size=15, color='red', symbol='star'),
        name='Current parameters'
    ))

    fig_vmax.update_layout(
        title='Maximum Velocity vs Bandwidth',
        xaxis_title=' [meV]',
        yaxis_title='v_max [m/s]',
        height=350,
        template='plotly_white'
    )

    tab5_content = mo.vstack([
        mo.md(rf"""
    ## Physical Parameters & Scaling Laws

    ### Current Parameters

    | Parameter | Symbol | Value |
    |-----------|--------|-------|
    | Bandwidth |  | {Delta_meV:.0f} meV |
    | Scattering time |  | {tau*1e12:.1f} ps |
    | Moire period | a_M | {a_M*1e9:.1f} nm |
    | Critical field | F_c | {F_c/1e3:.2f} kV/m |
    | Full density | n_full | {n_full:.2e} m |
    | Degeneracy | g | {g_degeneracy} |
    | Max velocity | v_max | {v_max:.1f} m/s |
    | Bloch period at F_c | T_B | {T_B*1e12:.2f} ps |

    ---

    ### Key Scaling Relations

    **1. Critical Field (independent of !):**
    $$
    F_c = \frac{{\hbar}}{{e \cdot a_M \cdot \tau}}
    $$

    This depends only on geometry ($a_M$) and scattering ($\tau$), NOT on bandwidth!
        """),
        fig_Fc_tau,
        mo.md(r"""
    **2. Maximum Velocity (proportional to ):**
    $$
    v_{\max} = \frac{\Delta \cdot a_M}{2\hbar}
    $$

    Narrower bands  slower carriers.
        """),
        fig_vmax,
        mo.md(r"""
    **3. Saturation Current:**
    $$
    j_{\text{sat}} \propto n_{2D} \cdot e \cdot v_{\max} \cdot f(\beta)
    $$

    where $f(\beta)$ is the filling-dependent form factor from 2D BZ integration.

    ---

    ### Physical Intuition

    - **F_c sets the NDR onset:** When the Bloch period $T_B = 2\pi\hbar/(eF a_M)$ equals $\tau$, scattering disrupts coherent oscillations.
    - ** controls current magnitude:** Bandwidth sets the velocity scale, but doesn't change when NDR occurs.
    - **2D reduces j_sat:** Phase-space effects from 2D BZ integration give $f_{2D} < f_{1D}$.
        """)
    ])
    return (tab5_content,)


@app.cell
def tab6_explorer_controls(beta_values, mo):
    # Create slider for beta selection
    beta_idx_slider = mo.ui.slider(
        start=0,
        stop=len(beta_values)-1,
        step=1,
        value=len(beta_values)//2,
        label=" index"
    )
    return (beta_idx_slider,)


@app.cell
def tab6_explorer(
    F_c,
    F_over_Fc,
    beta_idx_slider,
    beta_values,
    go,
    j_curves,
    j_max_values,
    mo,
    np,
):

    # Get selected beta
    idx = beta_idx_slider.value
    beta_selected = beta_values[idx]
    j_curve_selected = j_curves[idx]
    j_max_selected = j_max_values[idx]

    # Create j(F) plot for selected beta
    fig_jf_selected = go.Figure()

    fig_jf_selected.add_trace(go.Scatter(
        x=F_over_Fc,
        y=j_curve_selected,
        mode='lines',
        line=dict(width=3, color='blue'),
        name=f'j(F) at ={beta_selected:.2f}'
    ))

    # Mark maximum
    j_max_idx = np.argmax(j_curve_selected)
    fig_jf_selected.add_trace(go.Scatter(
        x=[F_over_Fc[j_max_idx]],
        y=[j_curve_selected[j_max_idx]],
        mode='markers',
        marker=dict(size=15, color='red', symbol='star'),
        name=f'j_max = {j_max_selected:.1f} A/m'
    ))

    # Add F_c line
    fig_jf_selected.add_vline(x=1.0, line_dash="dash", line_color="gray")

    fig_jf_selected.update_layout(
        title=f'Current-Field Curve at  = {beta_selected:.2f}',
        xaxis_title='F / F_c',
        yaxis_title='j [A/m]',
        height=400,
        template='plotly_white'
    )

    # Compute r_diff for this curve
    dj = np.diff(j_curve_selected)
    dF = np.diff(F_over_Fc * F_c)
    rdiff = np.where(np.abs(dj) > 0.001, dF / dj, np.nan)
    j_mid = (j_curve_selected[:-1] + j_curve_selected[1:]) / 2

    # Only show rising part (positive rdiff)
    valid = np.isfinite(rdiff) & (rdiff > 0) & (rdiff < 1e6) & (j_mid < j_max_selected)

    fig_rdiff = go.Figure()
    if np.sum(valid) > 2:
        fig_rdiff.add_trace(go.Scatter(
            x=j_mid[valid],
            y=rdiff[valid] / 1e3,  # kVm/A
            mode='lines',
            line=dict(width=3, color='green'),
            name='r_diff(j)'
        ))

    fig_rdiff.update_layout(
        title=f'Differential Resistance at  = {beta_selected:.2f}',
        xaxis_title='j [A/m]',
        yaxis_title='r_diff [kVm/A]',
        height=400,
        template='plotly_white'
    )

    # 1D Esaki-Tsu comparison
    def esaki_tsu_1d(x):
        """1D Esaki-Tsu: j/j_sat = x / (1 + x^2)"""
        return x / (1 + x**2)

    # Estimate j_sat from our data (at F=F_c, j should be j_sat/2 for 1D)
    j_at_Fc = np.interp(1.0, F_over_Fc, j_curve_selected)
    j_sat_est = j_max_selected  # Approximate

    j_1d = j_sat_est * esaki_tsu_1d(F_over_Fc)

    fig_compare_1d = go.Figure()
    fig_compare_1d.add_trace(go.Scatter(
        x=F_over_Fc,
        y=j_curve_selected,
        mode='lines',
        line=dict(width=3, color='blue'),
        name='2D C3 Numerical'
    ))
    fig_compare_1d.add_trace(go.Scatter(
        x=F_over_Fc,
        y=j_1d,
        mode='lines',
        line=dict(width=2, color='red', dash='dash'),
        name='1D Esaki-Tsu (scaled)'
    ))

    fig_compare_1d.update_layout(
        title='2D Model vs 1D Esaki-Tsu',
        xaxis_title='F / F_c',
        yaxis_title='j [A/m]',
        height=400,
        template='plotly_white'
    )

    tab6_content = mo.vstack([
        mo.md(rf"""
    ## Interactive Model Explorer

    Use the slider to explore different filling fractions.

    **Selected:**  = {beta_selected:.2f}
        """),
        beta_idx_slider,
        mo.hstack([
            mo.vstack([
                mo.md("### j(F) Curve"),
                fig_jf_selected
            ]),
            mo.vstack([
                mo.md("### r_diff(j)"),
                fig_rdiff
            ])
        ]),
        mo.md(r"""
    ### Comparison with 1D Esaki-Tsu

    The 1D formula predicts: $j = j_{\text{sat}} \cdot \frac{x}{1+x^2}$ where $x = F/F_c$.

    The 2D numerical model shows similar shape but with reduced magnitude due to phase-space effects.
        """),
        fig_compare_1d,
        mo.md(rf"""
    ### Summary for  = {beta_selected:.2f}

    | Quantity | Value |
    |----------|-------|
    | Maximum current | {j_max_selected:.1f} A/m |
    | F at j_max | {F_over_Fc[j_max_idx]:.2f} F_c = {F_over_Fc[j_max_idx]*F_c/1e3:.1f} kV/m |
        """)
    ])
    return (tab6_content,)


@app.cell
def tab7_physics_insight(go, mo, moire_dispersion, moire_velocity_x, np):
    """
    Educational tab explaining:
    A) Why filling dependence is crucial for maximum current
    B) Why C3 2D systems have smaller maximum current than 1D
    """

    # =========================================================================
    # SECTION A: FILLING DEPENDENCE - WHY IT MATTERS
    # =========================================================================

    # Create 1D band for comparison
    _k_1d = np.linspace(-np.pi, np.pi, 500)
    _E_1d = -np.cos(_k_1d)  # Simple cosine band, normalized
    _v_1d = np.sin(_k_1d)   # Velocity = dE/dk

    # Create filling slider values
    _beta_demo = np.linspace(0.05, 0.95, 19)

    # For each filling, compute Fermi level and current
    def _get_1d_current(_beta, _k, _E, _v):
        """Compute current for 1D band at given filling."""
        # Sort by energy
        _sort_idx = np.argsort(_E)
        _E_sorted = _E[_sort_idx]
        _v_sorted = _v[_sort_idx]

        # Fill up to beta fraction
        _n_filled = int(_beta * len(_k))
        if _n_filled == 0:
            return 0.0, -1.0

        _E_F = _E_sorted[_n_filled - 1]

        # Current from filled states (at equilibrium, this is zero!)
        # But we want to show the AVAILABLE velocity magnitude
        _v_filled = _v_sorted[:_n_filled]
        _v_pos = np.sum(_v_filled[_v_filled > 0])
        _v_neg = np.sum(_v_filled[_v_filled < 0])

        return _v_pos, _v_neg, _E_F

    # Create visualization: Band with Fermi level and velocity arrows
    # We'll create animation frames for different fillings

    _frames_filling = []
    _j_vs_beta_1d = []

    for _beta in _beta_demo:
        _v_pos, _v_neg, _E_F = _get_1d_current(_beta, _k_1d, _E_1d, _v_1d)

        # Net "available" velocity asymmetry (proxy for current under field)
        _j_proxy = _v_pos + _v_neg  # This shows the asymmetry
        _j_vs_beta_1d.append(np.abs(_v_pos - np.abs(_v_neg)))

        # Create frame showing band with filling
        _filled_mask = _E_1d <= _E_F

        _frame_data = [
            # Band structure
            go.Scatter(x=_k_1d, y=_E_1d, mode='lines',
                      line=dict(color='gray', width=1), name='Band'),
            # Filled states (positive velocity)
            go.Scatter(x=_k_1d[_filled_mask & (_v_1d > 0)],
                      y=_E_1d[_filled_mask & (_v_1d > 0)],
                      mode='markers', marker=dict(color='blue', size=4),
                      name='v > 0 (filled)'),
            # Filled states (negative velocity)
            go.Scatter(x=_k_1d[_filled_mask & (_v_1d < 0)],
                      y=_E_1d[_filled_mask & (_v_1d < 0)],
                      mode='markers', marker=dict(color='red', size=4),
                      name='v < 0 (filled)'),
            # Fermi level
            go.Scatter(x=[-np.pi, np.pi], y=[_E_F, _E_F],
                      mode='lines', line=dict(color='green', width=2, dash='dash'),
                      name=f'E_F (={_beta:.2f})')
        ]
        _frames_filling.append(go.Frame(data=_frame_data, name=f'{_beta:.2f}'))

    # Initial frame at =0.5
    _mid_idx = len(_beta_demo) // 2
    _v_pos, _v_neg, _E_F = _get_1d_current(_beta_demo[_mid_idx], _k_1d, _E_1d, _v_1d)
    _filled_mask = _E_1d <= _E_F

    fig_filling_1d = go.Figure(
        data=[
            go.Scatter(x=_k_1d, y=_E_1d, mode='lines',
                      line=dict(color='gray', width=1), name='Band'),
            go.Scatter(x=_k_1d[_filled_mask & (_v_1d > 0)],
                      y=_E_1d[_filled_mask & (_v_1d > 0)],
                      mode='markers', marker=dict(color='blue', size=4),
                      name='v > 0'),
            go.Scatter(x=_k_1d[_filled_mask & (_v_1d < 0)],
                      y=_E_1d[_filled_mask & (_v_1d < 0)],
                      mode='markers', marker=dict(color='red', size=4),
                      name='v < 0'),
            go.Scatter(x=[-np.pi, np.pi], y=[_E_F, _E_F],
                      mode='lines', line=dict(color='green', width=2, dash='dash'),
                      name='Fermi level')
        ],
        frames=_frames_filling
    )

    # Add slider for filling
    _steps_filling = []
    for _i, _beta in enumerate(_beta_demo):
        _steps_filling.append(dict(
            method='animate',
            args=[[f'{_beta:.2f}'], dict(mode='immediate', frame=dict(duration=0, redraw=True))],
            label=f'{_beta:.2f}'
        ))

    fig_filling_1d.update_layout(
        title='1D Band: Filling Determines Velocity Balance',
        xaxis_title='k',
        yaxis_title='(k)',
        height=400,
        template='plotly_white',
        sliders=[dict(
            active=_mid_idx,
            currentvalue=dict(prefix=' = '),
            steps=_steps_filling,
            x=0.1, len=0.8,
            y=-0.15
        )],
        legend=dict(x=1.02, y=1)
    )

    # =========================================================================
    # CURRENT VS FILLING: THE KEY INSIGHT
    # =========================================================================

    # For 1D cosine band, compute j_max analytically
    # At finite field, current is j   v(k) f(k-eEt/) dk
    # For steady state with scattering, this becomes the Esaki-Tsu result

    # Simulate j_max vs  for 1D
    _j_max_1d = []
    for _beta in np.linspace(0.01, 0.99, 50):
        # Approximate: j_max  (1-) for symmetric band
        # More precisely, it depends on the velocity distribution
        _n_filled = int(_beta * len(_k_1d))
        _sort_idx = np.argsort(_E_1d)
        _v_sorted = _v_1d[_sort_idx]
        _v_filled = _v_sorted[:_n_filled]
        # Maximum current when all velocities align (under strong field)
        _j_max_1d.append(np.mean(np.abs(_v_filled)) * _beta)

    _beta_range = np.linspace(0.01, 0.99, 50)

    # For 2D isotropic band: j  v_x with angular average
    # Angular average of cos() over Fermi circle = 0 at equilibrium
    # Under field, the shift gives j   but reduced by ~1/2 compared to 1D

    _j_max_2d_iso = np.array(_j_max_1d) * 0.5  # Rough factor for 2D

    # For C3 band: additional reduction due to trigonal warping
    _j_max_2d_c3 = np.array(_j_max_1d) * 0.35  # Even more reduced

    fig_j_vs_beta = go.Figure()
    fig_j_vs_beta.add_trace(go.Scatter(
        x=_beta_range, y=_j_max_1d / np.max(_j_max_1d),
        mode='lines', line=dict(color='blue', width=3),
        name='1D cosine band'
    ))
    fig_j_vs_beta.add_trace(go.Scatter(
        x=_beta_range, y=_j_max_2d_iso / np.max(_j_max_1d),
        mode='lines', line=dict(color='orange', width=3, dash='dash'),
        name='2D isotropic'
    ))
    fig_j_vs_beta.add_trace(go.Scatter(
        x=_beta_range, y=_j_max_2d_c3 / np.max(_j_max_1d),
        mode='lines', line=dict(color='red', width=3, dash='dot'),
        name='2D C3 symmetric'
    ))

    # Mark optimal filling
    _opt_idx = np.argmax(_j_max_1d)
    fig_j_vs_beta.add_vline(x=_beta_range[_opt_idx], line_dash="dash",
                            line_color="gray", opacity=0.5)
    fig_j_vs_beta.add_annotation(
        x=_beta_range[_opt_idx], y=1.05,
        text=f"Optimal   {_beta_range[_opt_idx]:.2f}",
        showarrow=False, font=dict(size=12)
    )

    fig_j_vs_beta.update_layout(
        title='Maximum Current vs Filling Fraction',
        xaxis_title=' (filling fraction)',
        yaxis_title='j_max (normalized)',
        height=400,
        template='plotly_white',
        legend=dict(x=0.02, y=0.98)
    )

    # =========================================================================
    # SECTION B: WHY 2D C3 HAS SMALLER CURRENT
    # =========================================================================

    # Create 2D visualization showing velocity field and angular distribution

    _kx_2d = np.linspace(-np.pi, np.pi, 80)
    _ky_2d = np.linspace(-np.pi, np.pi, 80)
    _KX, _KY = np.meshgrid(_kx_2d, _ky_2d)

    _Delta = 0.08  # 80 meV
    _E_2d = moire_dispersion(_KX, _KY, _Delta)
    _Vx_2d = moire_velocity_x(_KX, _KY, _Delta)

    # Compute Vy for C3 band
    def _moire_vy(_kx, _ky, _Delta):
        _G2_dot_k = -0.5*_kx + np.sqrt(3)/2*_ky
        _G3_dot_k = -0.5*_kx - np.sqrt(3)/2*_ky
        return (_Delta/3) * (np.sin(_G2_dot_k)*(np.sqrt(3)/2) + np.sin(_G3_dot_k)*(-np.sqrt(3)/2))

    _Vy_2d = _moire_vy(_KX, _KY, _Delta)
    _V_mag = np.sqrt(_Vx_2d**2 + _Vy_2d**2)

    # Velocity field plot with arrows
    _skip = 8  # Downsample for arrows
    _kx_arrow = _KX[::_skip, ::_skip].flatten()
    _ky_arrow = _KY[::_skip, ::_skip].flatten()
    _vx_arrow = _Vx_2d[::_skip, ::_skip].flatten()
    _vy_arrow = _Vy_2d[::_skip, ::_skip].flatten()
    _v_mag_arrow = np.sqrt(_vx_arrow**2 + _vy_arrow**2)

    # Normalize arrows
    _scale = 0.4
    _vx_norm = _vx_arrow / (_v_mag_arrow + 0.001) * _scale
    _vy_norm = _vy_arrow / (_v_mag_arrow + 0.001) * _scale

    fig_velocity_field = go.Figure()

    # Background: energy contours
    fig_velocity_field.add_trace(go.Contour(
        x=_kx_2d, y=_ky_2d, z=_E_2d * 1000,
        colorscale='Greys', opacity=0.3,
        showscale=False,
        contours=dict(coloring='lines', showlabels=False),
        name='Energy contours'
    ))

    # Color arrows by vx (contribution to current along x)
    _colors = np.where(_vx_arrow > 0, 'blue', 'red')

    # Add velocity arrows as lines
    for _i in range(len(_kx_arrow)):
        if _v_mag_arrow[_i] > 0.001:  # Only show non-zero velocities
            fig_velocity_field.add_trace(go.Scatter(
                x=[_kx_arrow[_i], _kx_arrow[_i] + _vx_norm[_i]],
                y=[_ky_arrow[_i], _ky_arrow[_i] + _vy_norm[_i]],
                mode='lines',
                line=dict(color=_colors[_i], width=1.5),
                showlegend=False,
                hoverinfo='skip'
            ))

    # Add legend entries
    fig_velocity_field.add_trace(go.Scatter(
        x=[None], y=[None], mode='lines',
        line=dict(color='blue', width=2), name='v > 0 (+ current)'
    ))
    fig_velocity_field.add_trace(go.Scatter(
        x=[None], y=[None], mode='lines',
        line=dict(color='red', width=2), name='v < 0 ( current)'
    ))

    fig_velocity_field.update_layout(
        title='C3 Velocity Field: Arrows Show v(k), Color = Sign of v',
        xaxis_title='k', yaxis_title='k',
        height=500, width=550,
        template='plotly_white',
        xaxis=dict(scaleanchor='y'),
        legend=dict(x=1.02, y=1)
    )

    # =========================================================================
    # ANGULAR DISTRIBUTION OF VELOCITY
    # =========================================================================

    # Sample velocities on a Fermi contour and show angular distribution
    _E_fermi = 0.04  # 40 meV Fermi energy

    # Find points near Fermi surface
    _fermi_mask = np.abs(_E_2d - _E_fermi) < 0.005

    _vx_fermi = _Vx_2d[_fermi_mask]
    _vy_fermi = _Vy_2d[_fermi_mask]
    _angles_fermi = np.arctan2(_vy_fermi, _vx_fermi)

    # Histogram of velocity angles
    _angle_bins = np.linspace(-np.pi, np.pi, 37)
    _angle_hist, _ = np.histogram(_angles_fermi, bins=_angle_bins)

    # For 1D comparison: all velocities at 0 or 
    _angle_hist_1d = np.zeros_like(_angle_hist)
    _angle_hist_1d[0] = 50  # All at =0 or 
    _angle_hist_1d[-2] = 50

    # For isotropic 2D: uniform distribution
    _angle_hist_iso = np.ones_like(_angle_hist) * np.mean(_angle_hist)

    _angle_centers = (_angle_bins[:-1] + _angle_bins[1:]) / 2

    fig_angle_dist = go.Figure()

    # C3 distribution
    fig_angle_dist.add_trace(go.Barpolar(
        r=_angle_hist / np.max(_angle_hist),
        theta=np.degrees(_angle_centers),
        name='C3 band',
        marker_color='red',
        opacity=0.7
    ))

    fig_angle_dist.add_trace(go.Scatterpolar(
        r=_angle_hist_iso / np.max(_angle_hist),
        theta=np.degrees(_angle_centers),
        mode='lines',
        name='Isotropic 2D',
        line=dict(color='orange', width=2)
    ))

    fig_angle_dist.update_layout(
        title='Angular Distribution of Velocity on Fermi Surface',
        polar=dict(
            radialaxis=dict(showticklabels=False, ticks=''),
            angularaxis=dict(direction='counterclockwise')
        ),
        height=400,
        template='plotly_white',
        legend=dict(x=1.02, y=1),
        annotations=[
            dict(x=0.5, y=-0.15, xref='paper', yref='paper',
                 text='=0 is along E-field  only cos() component contributes to current',
                 showarrow=False, font=dict(size=11))
        ]
    )

    # =========================================================================
    # CURRENT CONTRIBUTION VISUALIZATION
    # =========================================================================

    # Show j_x = v_x * f(k) contribution across BZ

    # For T=0, f(k) = (E_F - E(k))
    _E_F_demo = 0.03  # 30 meV
    _f_k = (_E_2d <= _E_F_demo).astype(float)
    _j_contribution = _Vx_2d * _f_k

    fig_current_contrib = go.Figure()

    # Positive contributions
    fig_current_contrib.add_trace(go.Contour(
        x=_kx_2d, y=_ky_2d,
        z=np.where(_j_contribution > 0, _j_contribution, 0) * 1000,
        colorscale='Blues',
        contours=dict(coloring='heatmap'),
        showscale=True,
        colorbar=dict(title='j [meV]', x=1.0, len=0.45, y=0.75),
        name='Positive j'
    ))

    # Negative contributions (separate colorbar)
    fig_current_contrib.add_trace(go.Contour(
        x=_kx_2d, y=_ky_2d,
        z=np.where(_j_contribution < 0, -_j_contribution, 0) * 1000,
        colorscale='Reds',
        contours=dict(coloring='heatmap'),
        showscale=True,
        colorbar=dict(title='j [meV]', x=1.15, len=0.45, y=0.25),
        name='Negative j',
        opacity=0.7
    ))

    # Fermi contour
    fig_current_contrib.add_trace(go.Contour(
        x=_kx_2d, y=_ky_2d, z=_E_2d,
        contours=dict(
            start=_E_F_demo, end=_E_F_demo, size=0.001,
            coloring='lines', showlabels=False
        ),
        line=dict(color='black', width=2),
        showscale=False,
        name='Fermi surface'
    ))

    fig_current_contrib.update_layout(
        title=f'Current Density Contributions at E_F = {_E_F_demo*1000:.0f} meV<br>' +
              '<span style="color:blue">Blue = +j</span>, <span style="color:red">Red = j</span>',
        xaxis_title='k', yaxis_title='k',
        height=500,
        template='plotly_white',
        xaxis=dict(scaleanchor='y')
    )

    # =========================================================================
    # QUANTITATIVE COMPARISON: 1D vs 2D
    # =========================================================================

    # Create bar chart showing reduction factors
    _systems = ['1D Cosine Band', '2D Isotropic', '2D C3 Symmetric']
    _j_max_relative = [1.0, 0.5, 0.35]
    _colors_bar = ['blue', 'orange', 'red']

    fig_comparison_bar = go.Figure()
    fig_comparison_bar.add_trace(go.Bar(
        x=_systems,
        y=_j_max_relative,
        marker_color=_colors_bar,
        text=[f'{v:.0%}' for v in _j_max_relative],
        textposition='outside'
    ))

    fig_comparison_bar.update_layout(
        title='Maximum Current: Dimensional Reduction',
        yaxis_title='j_max / j_max(1D)',
        height=350,
        template='plotly_white',
        yaxis=dict(range=[0, 1.2])
    )

    # =========================================================================
    # WHY THE REDUCTION? - PHYSICAL EXPLANATION
    # =========================================================================

    # Create an animation showing how angular averaging reduces current

    # Polar plot: velocity components along field direction
    _theta_demo = np.linspace(0, 2*np.pi, 100)

    # 1D: delta functions at 0 and 
    # 2D isotropic: cos() distribution
    # 2D C3: cos() with trigonal modulation

    _v_parallel_1d = np.zeros_like(_theta_demo)
    _v_parallel_1d[0] = 1
    _v_parallel_1d[50] = -1

    _v_parallel_2d_iso = np.cos(_theta_demo)
    _v_parallel_2d_c3 = np.cos(_theta_demo) * (1 + 0.3 * np.cos(3*_theta_demo))

    fig_angular_current = go.Figure()

    fig_angular_current.add_trace(go.Scatterpolar(
        r=np.abs(_v_parallel_2d_iso),
        theta=np.degrees(_theta_demo),
        mode='lines',
        name='2D isotropic: |cos |',
        line=dict(color='orange', width=2)
    ))

    fig_angular_current.add_trace(go.Scatterpolar(
        r=np.abs(_v_parallel_2d_c3),
        theta=np.degrees(_theta_demo),
        mode='lines',
        name='2D C3: |cos |  (1+0.3cos3)',
        line=dict(color='red', width=2)
    ))

    # Highlight the field direction
    fig_angular_current.add_trace(go.Scatterpolar(
        r=[0, 1.3],
        theta=[0, 0],
        mode='lines+text',
        line=dict(color='green', width=3, dash='dash'),
        text=['', 'E-field'],
        textposition='top right',
        name='Field direction'
    ))

    fig_angular_current.update_layout(
        title='Velocity Component Along Field Direction',
        polar=dict(
            radialaxis=dict(range=[0, 1.4]),
            angularaxis=dict(direction='counterclockwise')
        ),
        height=400,
        template='plotly_white',
        legend=dict(x=1.02, y=1)
    )

    # =========================================================================
    # INTERACTIVE: FERMI SURFACE EVOLUTION
    # =========================================================================

    # Show Fermi surface at different fillings with net current arrow

    _E_fermi_values = np.linspace(0.01, 0.07, 7)  # Different Fermi energies

    _frames_fermi = []
    _net_jx_vs_Ef = []

    for _Ef in _E_fermi_values:
        _fermi_mask = np.abs(_E_2d - _Ef) < 0.003
        _filled_mask = _E_2d <= _Ef

        # Compute net current
        _net_jx = np.mean(_Vx_2d[_filled_mask]) if np.any(_filled_mask) else 0
        _net_jx_vs_Ef.append(np.sum(_Vx_2d[_filled_mask]))

        _frame_data = [
            # Energy contours
            go.Contour(x=_kx_2d, y=_ky_2d, z=_E_2d*1000,
                      colorscale='Viridis', showscale=True,
                      colorbar=dict(title=' [meV]'),
                      contours=dict(coloring='heatmap')),
            # Fermi contour
            go.Contour(x=_kx_2d, y=_ky_2d, z=_E_2d,
                      contours=dict(start=_Ef, end=_Ef, size=0.001, coloring='lines'),
                      line=dict(color='white', width=3),
                      showscale=False)
        ]
        _frames_fermi.append(go.Frame(data=_frame_data, name=f'{_Ef*1000:.0f}'))

    # Initial frame
    _Ef_init = _E_fermi_values[3]
    fig_fermi_evolution = go.Figure(
        data=[
            go.Contour(x=_kx_2d, y=_ky_2d, z=_E_2d*1000,
                      colorscale='Viridis', showscale=True,
                      colorbar=dict(title=' [meV]'),
                      contours=dict(coloring='heatmap')),
            go.Contour(x=_kx_2d, y=_ky_2d, z=_E_2d,
                      contours=dict(start=_Ef_init, end=_Ef_init, size=0.001, coloring='lines'),
                      line=dict(color='white', width=3),
                      showscale=False)
        ],
        frames=_frames_fermi
    )

    _steps_fermi = []
    for _i, _Ef in enumerate(_E_fermi_values):
        _steps_fermi.append(dict(
            method='animate',
            args=[[f'{_Ef*1000:.0f}'], dict(mode='immediate', frame=dict(duration=0, redraw=True))],
            label=f'{_Ef*1000:.0f} meV'
        ))

    fig_fermi_evolution.update_layout(
        title='Fermi Surface Evolution with Filling (White = Fermi Contour)',
        xaxis_title='k', yaxis_title='k',
        height=450,
        template='plotly_white',
        xaxis=dict(scaleanchor='y'),
        sliders=[dict(
            active=3,
            currentvalue=dict(prefix='E_F = '),
            steps=_steps_fermi,
            x=0.1, len=0.8, y=-0.12
        )]
    )

    # =========================================================================
    # PART C: DRIVING FIELD EFFECTS IN 2D C3 SYSTEMS
    # =========================================================================

    # --- Setup: 2D C3 band structure ---
    _n_k_c3 = 80
    _kx_c3 = np.linspace(-np.pi, np.pi, _n_k_c3)
    _ky_c3 = np.linspace(-np.pi, np.pi, _n_k_c3)
    _KX_c3, _KY_c3 = np.meshgrid(_kx_c3, _ky_c3)

    _Delta_c3 = 0.08  # 80 meV bandwidth

    # C3 dispersion and velocities
    _E_c3 = moire_dispersion(_KX_c3, _KY_c3, _Delta_c3)
    _Vx_c3 = moire_velocity_x(_KX_c3, _KY_c3, _Delta_c3)

    def _moire_vy_c3(_kx, _ky, _Delta):
        _G2 = -0.5*_kx + np.sqrt(3)/2*_ky
        _G3 = -0.5*_kx - np.sqrt(3)/2*_ky
        return (_Delta/3) * (np.sin(_G2)*(np.sqrt(3)/2) + np.sin(_G3)*(-np.sqrt(3)/2))

    _Vy_c3 = _moire_vy_c3(_KX_c3, _KY_c3, _Delta_c3)
    _V_mag_c3 = np.sqrt(_Vx_c3**2 + _Vy_c3**2)

    # --- Figure 1: 3D Distribution Function Under Field ---
    # Show how f(k) shifts and distorts under driving field

    def _compute_driven_distribution(_kx, _ky, _E, _E_F, _delta_k, _T_eff=0.005):
        """
        Compute non-equilibrium distribution under field.
        Field shifts distribution: f(k)  f(k - k) with smearing.
        """
        # Shifted k-coordinates (field along x)
        _kx_shifted = _kx - _delta_k
        # Wrap to BZ
        _kx_shifted_wrapped = ((_kx_shifted + np.pi) % (2*np.pi)) - np.pi
        # Recompute energy at shifted k
        _E_shifted = moire_dispersion(_kx_shifted_wrapped, _ky, _Delta_c3)
        # Smeared Fermi function (finite  broadening)
        _f = 1 / (1 + np.exp((_E_shifted - _E_F) / (_T_eff + 0.001)))
        return _f

    # Different field strengths (k = F**e/  F/F_c)
    _delta_k_values_c3 = [0, 0.3*np.pi, 0.6*np.pi, 1.0*np.pi, 1.5*np.pi]
    _F_labels_c3 = ['F=0', 'F=0.3Fc', 'F=0.6Fc', 'F=Fc', 'F=1.5Fc']

    _E_F_c3 = 0.04  # 40 meV Fermi energy (intermediate filling)

    _frames_dist_2d = []
    for _dk, _label in zip(_delta_k_values_c3, _F_labels_c3):
        _f_driven = _compute_driven_distribution(_KX_c3, _KY_c3, _E_c3, _E_F_c3, _dk)
        _frames_dist_2d.append(go.Frame(
            data=[go.Contour(x=_kx_c3, y=_ky_c3, z=_f_driven,
                            colorscale='Blues', zmin=0, zmax=1,
                            colorbar=dict(title='f(k)'),
                            contours=dict(showlines=True))],
            name=_label
        ))

    _f_init = _compute_driven_distribution(_KX_c3, _KY_c3, _E_c3, _E_F_c3, 0)

    fig_dist_3d = go.Figure(
        data=[go.Contour(x=_kx_c3, y=_ky_c3, z=_f_init,
                        colorscale='Blues', zmin=0, zmax=1,
                        colorbar=dict(title='f(k)', len=0.6),
                        contours=dict(showlines=True))],
        frames=_frames_dist_2d
    )

    _steps_dist_2d = [dict(method='animate',
                           args=[[_label], dict(mode='immediate', frame=dict(duration=0, redraw=True))],
                           label=_label) for _label in _F_labels_c3]

    fig_dist_3d.update_layout(
        title='Distribution Function f(k, k) Under Driving Field',
        xaxis_title='k', yaxis_title='k',
        xaxis=dict(tickvals=[-np.pi, 0, np.pi], ticktext=['-', '0', ''], scaleanchor='y'),
        yaxis=dict(tickvals=[-np.pi, 0, np.pi], ticktext=['-', '0', '']),
        height=450,
        template='plotly_white',
        sliders=[dict(active=0, currentvalue=dict(prefix=''), steps=_steps_dist_2d,
                     x=0.1, len=0.8, y=0)]
    )

    # --- Figure 2: Current Contribution j_x(k) = v_x(k) * f(k) ---

    _frames_jx_2d = []
    for _dk, _label in zip(_delta_k_values_c3, _F_labels_c3):
        _f_driven = _compute_driven_distribution(_KX_c3, _KY_c3, _E_c3, _E_F_c3, _dk)
        _jx_contrib = _Vx_c3 * _f_driven * 1000  # meV units
        _frames_jx_2d.append(go.Frame(
            data=[go.Contour(x=_kx_c3, y=_ky_c3, z=_jx_contrib,
                            colorscale='RdBu_r', zmid=0,
                            colorbar=dict(title='j(k) [meV]'),
                            contours=dict(showlines=True))],
            name=_label
        ))

    _jx_init = _Vx_c3 * _f_init * 1000

    fig_jx_3d = go.Figure(
        data=[go.Contour(x=_kx_c3, y=_ky_c3, z=_jx_init,
                        colorscale='RdBu_r', zmid=0,
                        colorbar=dict(title='j(k) [meV]', len=0.6),
                        contours=dict(showlines=True))],
        frames=_frames_jx_2d
    )

    fig_jx_3d.update_layout(
        title='Current Contribution j(k) = v(k)f(k)',
        xaxis_title='k', yaxis_title='k',
        xaxis=dict(tickvals=[-np.pi, 0, np.pi], ticktext=['-', '0', ''], scaleanchor='y'),
        yaxis=dict(tickvals=[-np.pi, 0, np.pi], ticktext=['-', '0', '']),
        height=450,
        template='plotly_white',
        sliders=[dict(active=0, currentvalue=dict(prefix=''), steps=_steps_dist_2d,
                     x=0.1, len=0.8, y=0)]
    )

    # --- Figure 3: Heatmap of distribution at different F (2D view) ---

    from plotly.subplots import make_subplots as _make_subplots_c3

    fig_dist_heatmaps = _make_subplots_c3(
        rows=1, cols=4,
        subplot_titles=['F=0 (Equilibrium)', 'F=0.5Fc', 'F=Fc', 'F=1.5Fc'],
        horizontal_spacing=0.08
    )

    _F_heatmap_vals = [0, 0.5*np.pi, 1.0*np.pi, 1.5*np.pi]
    for _i_col, _dk in enumerate(_F_heatmap_vals):
        _f_driven = _compute_driven_distribution(_KX_c3, _KY_c3, _E_c3, _E_F_c3, _dk)
        fig_dist_heatmaps.add_trace(
            go.Heatmap(x=_kx_c3, y=_ky_c3, z=_f_driven,
                      colorscale='Blues', zmin=0, zmax=1, showscale=(_i_col == 3),
                      colorbar=dict(title='f(k)', x=1.02) if _i_col == 3 else None),
            row=1, col=_i_col+1
        )
        # Add Fermi contour
        fig_dist_heatmaps.add_trace(
            go.Contour(x=_kx_c3, y=_ky_c3, z=_E_c3,
                      contours=dict(start=_E_F_c3, end=_E_F_c3, size=0.001, coloring='lines'),
                      line=dict(color='red', width=2), showscale=False),
            row=1, col=_i_col+1
        )

    fig_dist_heatmaps.update_layout(
        title='Distribution f(k) Shift Under Driving Field (Red = Fermi Surface)',
        height=350,
        template='plotly_white'
    )
    for _i in range(1, 5):
        fig_dist_heatmaps.update_xaxes(title_text='k', row=1, col=_i,
                                       tickvals=[-np.pi, 0, np.pi], ticktext=['-', '0', ''])
        fig_dist_heatmaps.update_yaxes(title_text='k' if _i == 1 else '', row=1, col=_i,
                                       tickvals=[-np.pi, 0, np.pi], ticktext=['-', '0', ''],
                                       scaleanchor=f'x{_i}' if _i > 1 else 'x')

    # --- Figure 4: Current integrand heatmaps at different F ---

    fig_jx_heatmaps = _make_subplots_c3(
        rows=1, cols=4,
        subplot_titles=['F=0', 'F=0.5Fc', 'F=Fc', 'F=1.5Fc'],
        horizontal_spacing=0.08
    )

    for _i_col, _dk in enumerate(_F_heatmap_vals):
        _f_driven = _compute_driven_distribution(_KX_c3, _KY_c3, _E_c3, _E_F_c3, _dk)
        _jx_contrib = _Vx_c3 * _f_driven * 1000
        fig_jx_heatmaps.add_trace(
            go.Heatmap(x=_kx_c3, y=_ky_c3, z=_jx_contrib,
                      colorscale='RdBu_r', zmid=0, showscale=(_i_col == 3),
                      colorbar=dict(title='j [meV]', x=1.02) if _i_col == 3 else None),
            row=1, col=_i_col+1
        )

    fig_jx_heatmaps.update_layout(
        title='Current Integrand j(k) = vf at Different Field Strengths (Blue=+, Red=)',
        height=350,
        template='plotly_white'
    )
    for _i in range(1, 5):
        fig_jx_heatmaps.update_xaxes(title_text='k', row=1, col=_i,
                                     tickvals=[-np.pi, 0, np.pi], ticktext=['-', '0', ''])
        fig_jx_heatmaps.update_yaxes(title_text='k' if _i == 1 else '', row=1, col=_i,
                                     tickvals=[-np.pi, 0, np.pi], ticktext=['-', '0', ''])

    # --- Figure 5: Filling dependence - distributions at different  ---

    _beta_viz = [0.2, 0.4, 0.6, 0.8]
    _E_F_from_beta = [0.02, 0.04, 0.06, 0.075]  # Approximate E_F for each 

    fig_filling_dist = _make_subplots_c3(
        rows=2, cols=4,
        subplot_titles=[f'={b}, F=0' for b in _beta_viz] + [f'={b}, F=Fc' for b in _beta_viz],
        vertical_spacing=0.12,
        horizontal_spacing=0.06
    )

    for _i_col, (_beta, _E_F_b) in enumerate(zip(_beta_viz, _E_F_from_beta)):
        # Equilibrium (F=0)
        _f_eq = _compute_driven_distribution(_KX_c3, _KY_c3, _E_c3, _E_F_b, 0)
        fig_filling_dist.add_trace(
            go.Heatmap(x=_kx_c3, y=_ky_c3, z=_f_eq,
                      colorscale='Blues', zmin=0, zmax=1, showscale=False),
            row=1, col=_i_col+1
        )
        # Driven (F=Fc)
        _f_dr = _compute_driven_distribution(_KX_c3, _KY_c3, _E_c3, _E_F_b, 1.0*np.pi)
        fig_filling_dist.add_trace(
            go.Heatmap(x=_kx_c3, y=_ky_c3, z=_f_dr,
                      colorscale='Blues', zmin=0, zmax=1, showscale=(_i_col == 3)),
            row=2, col=_i_col+1
        )

    fig_filling_dist.update_layout(
        title='Distribution at Different Fillings: Equilibrium (top) vs Driven at F=Fc (bottom)',
        height=550,
        template='plotly_white'
    )

    # --- Figure 6: Net current vs F for different fillings ---

    def _compute_net_current_c3(_delta_k, _E_F):
        """Compute net current by integrating jx over BZ."""
        _f = _compute_driven_distribution(_KX_c3, _KY_c3, _E_c3, _E_F, _delta_k)
        _jx = _Vx_c3 * _f
        return np.sum(_jx)  # Proportional to total current

    _F_range_c3 = np.linspace(0, 2.5, 50)
    _delta_k_range = _F_range_c3 * np.pi  # k = F/Fc * 

    fig_jF_filling = go.Figure()
    _colors_beta = ['purple', 'blue', 'green', 'orange']

    for _beta, _E_F_b, _color in zip(_beta_viz, _E_F_from_beta, _colors_beta):
        _j_vs_F = [_compute_net_current_c3(_dk, _E_F_b) for _dk in _delta_k_range]
        _j_vs_F = np.array(_j_vs_F)
        _j_vs_F = _j_vs_F / (np.max(np.abs(_j_vs_F)) + 0.001)  # Normalize each curve

        fig_jF_filling.add_trace(go.Scatter(
            x=_F_range_c3, y=_j_vs_F,
            mode='lines',
            line=dict(color=_color, width=3),
            name=f' = {_beta}'
        ))

    fig_jF_filling.add_vline(x=1.0, line_dash='dash', line_color='gray', opacity=0.5)
    fig_jF_filling.add_annotation(x=1.0, y=1.05, text='F = Fc', showarrow=False)

    fig_jF_filling.update_layout(
        title='j(F) Curves for Different Fillings in 2D C3 System',
        xaxis_title='F / Fc',
        yaxis_title='j / j_max (normalized per )',
        height=400,
        template='plotly_white',
        legend=dict(x=1.02, y=1)
    )

    # --- Figure 7: 2D Phase diagram j(F, ) heatmap ---

    _n_F_pd = 40
    _n_beta_pd = 30
    _F_pd = np.linspace(0.1, 2.5, _n_F_pd)
    _beta_pd = np.linspace(0.1, 0.9, _n_beta_pd)
    _E_F_pd = np.linspace(0.01, 0.075, _n_beta_pd)  # E_F corresponding to 

    _j_phase_diagram = np.zeros((_n_beta_pd, _n_F_pd))

    for _i_b, _E_F_b in enumerate(_E_F_pd):
        for _i_F, _F_val in enumerate(_F_pd):
            _dk = _F_val * np.pi
            _j_phase_diagram[_i_b, _i_F] = _compute_net_current_c3(_dk, _E_F_b)

    # Normalize
    _j_phase_diagram = _j_phase_diagram / (np.max(np.abs(_j_phase_diagram)) + 0.001)

    fig_phase_diagram_c3 = go.Figure()

    fig_phase_diagram_c3.add_trace(go.Heatmap(
        x=_F_pd, y=_beta_pd, z=_j_phase_diagram,
        colorscale='Viridis',
        colorbar=dict(title='j (norm)')
    ))

    # Add contours
    fig_phase_diagram_c3.add_trace(go.Contour(
        x=_F_pd, y=_beta_pd, z=_j_phase_diagram,
        contours=dict(coloring='lines', showlabels=True, labelfont=dict(size=10, color='white')),
        line=dict(color='white', width=1),
        showscale=False
    ))

    # Mark j_max ridge
    _j_max_idx = np.argmax(_j_phase_diagram, axis=1)
    _F_at_jmax_c3 = _F_pd[_j_max_idx]

    fig_phase_diagram_c3.add_trace(go.Scatter(
        x=_F_at_jmax_c3, y=_beta_pd,
        mode='lines+markers',
        line=dict(color='red', width=3),
        marker=dict(size=5, color='red'),
        name='j_max ridge'
    ))

    fig_phase_diagram_c3.update_layout(
        title='Phase Diagram: Current j(F/Fc, ) in 2D C3 System',
        xaxis_title='F / Fc',
        yaxis_title=' (filling)',
        height=500,
        template='plotly_white'
    )

    # --- Figure 8: Current vector field in k-space ---

    _skip_v = 6
    _kx_v = _KX_c3[::_skip_v, ::_skip_v].flatten()
    _ky_v = _KY_c3[::_skip_v, ::_skip_v].flatten()

    # At F = Fc
    _f_driven_v = _compute_driven_distribution(_KX_c3, _KY_c3, _E_c3, _E_F_c3, np.pi)
    _jx_v = (_Vx_c3 * _f_driven_v)[::_skip_v, ::_skip_v].flatten()
    _jy_v = (_Vy_c3 * _f_driven_v)[::_skip_v, ::_skip_v].flatten()
    _j_mag_v = np.sqrt(_jx_v**2 + _jy_v**2)

    # Normalize arrows
    _scale_v = 0.5
    _jx_norm = _jx_v / (_j_mag_v.max() + 0.001) * _scale_v
    _jy_norm = _jy_v / (_j_mag_v.max() + 0.001) * _scale_v

    fig_current_vectors = go.Figure()

    # Background: distribution
    fig_current_vectors.add_trace(go.Heatmap(
        x=_kx_c3, y=_ky_c3, z=_f_driven_v,
        colorscale='Blues', opacity=0.5, showscale=False
    ))

    # Current vectors as lines (color by jx sign)
    for _i_v in range(len(_kx_v)):
        if _j_mag_v[_i_v] > 0.01 * _j_mag_v.max():
            _color_v = 'red' if _jx_v[_i_v] > 0 else 'blue'
            fig_current_vectors.add_trace(go.Scatter(
                x=[_kx_v[_i_v], _kx_v[_i_v] + _jx_norm[_i_v]],
                y=[_ky_v[_i_v], _ky_v[_i_v] + _jy_norm[_i_v]],
                mode='lines',
                line=dict(color=_color_v, width=1.5),
                showlegend=False, hoverinfo='skip'
            ))

    # Legend
    fig_current_vectors.add_trace(go.Scatter(x=[None], y=[None], mode='lines',
                                             line=dict(color='red', width=2), name='j > 0'))
    fig_current_vectors.add_trace(go.Scatter(x=[None], y=[None], mode='lines',
                                             line=dict(color='blue', width=2), name='j < 0'))

    fig_current_vectors.update_layout(
        title='Current Density Vector Field j(k) at F=Fc',
        xaxis_title='k', yaxis_title='k',
        xaxis=dict(scaleanchor='y', tickvals=[-np.pi, 0, np.pi], ticktext=['-', '0', '']),
        yaxis=dict(tickvals=[-np.pi, 0, np.pi], ticktext=['-', '0', '']),
        height=500,
        template='plotly_white',
        legend=dict(x=1.02, y=1)
    )

    # --- Figure 9: Comparison equilibrium vs driven (side by side 2D contours) ---

    fig_eq_vs_driven = _make_subplots_c3(
        rows=1, cols=2,
        subplot_titles=['Equilibrium f(k), F=0', 'Driven f(k), F=Fc'],
        horizontal_spacing=0.1
    )

    _f_eq_2d = _compute_driven_distribution(_KX_c3, _KY_c3, _E_c3, _E_F_c3, 0)
    _f_dr_2d = _compute_driven_distribution(_KX_c3, _KY_c3, _E_c3, _E_F_c3, np.pi)

    fig_eq_vs_driven.add_trace(
        go.Contour(x=_kx_c3, y=_ky_c3, z=_f_eq_2d, colorscale='Blues',
                  zmin=0, zmax=1, showscale=False,
                  contours=dict(showlines=True)),
        row=1, col=1
    )
    fig_eq_vs_driven.add_trace(
        go.Contour(x=_kx_c3, y=_ky_c3, z=_f_dr_2d, colorscale='Oranges',
                  zmin=0, zmax=1, colorbar=dict(title='f(k)', x=1.02, len=0.6),
                  contours=dict(showlines=True)),
        row=1, col=2
    )

    fig_eq_vs_driven.update_layout(
        title='Distribution Shift: Equilibrium (Blue) vs Driven at F=Fc (Orange)',
        height=400,
        template='plotly_white'
    )
    for _i in range(1, 3):
        fig_eq_vs_driven.update_xaxes(title_text='k', row=1, col=_i,
                                      tickvals=[-np.pi, 0, np.pi], ticktext=['-', '0', ''])
        fig_eq_vs_driven.update_yaxes(title_text='k' if _i == 1 else '', row=1, col=_i,
                                      tickvals=[-np.pi, 0, np.pi], ticktext=['-', '0', ''],
                                      scaleanchor=f'x{_i}' if _i > 1 else 'x')

    # =========================================================================
    # ASSEMBLE THE TAB
    # =========================================================================

    tab7_content = mo.vstack([
        mo.md(r"""
    # Why Filling Matters & Why 2D C3 Systems Have Lower Current

    This tab provides an intuitive, visual understanding of two key questions:

    **A)** Why is the filling fraction $\beta$ so important for the maximum achievable current?

    **B)** Why do 2D systems with C3 symmetry have smaller maximum current than 1D systems?

    ---

    ## Part A: The Filling Dependence

    ### The Fundamental Balance

    In any band, electrons have velocities $\mathbf{v}(\mathbf{k}) = \frac{1}{\hbar}\nabla_k \varepsilon(\mathbf{k})$.

    **Key insight:** In a completely filled band, there are equal numbers of electrons moving in opposite directions  **zero net current**!

    The filling fraction $\beta$ determines the balance between:
    -  States with positive velocity (contribute +j)
    -  States with negative velocity (contribute j)

    ### Interactive 1D Example

    Use the slider to see how filling changes the velocity balance:
        """),

        fig_filling_1d,

        mo.md(r"""
    ### The Sweet Spot

    At intermediate filling ($\beta \approx 0.5-0.7$), you get:
    -  Enough carriers to conduct
    -  Maximum asymmetry between +v and v states
    -  Optimal current

    At extreme fillings:
    -  $\beta \to 0$: No carriers  no current
    -  $\beta \to 1$: Full band  velocities cancel
        """),

        mo.hstack([
            fig_j_vs_beta,
            mo.vstack([
                mo.md(r"""
    ### Maximum Current vs Filling

    The curves show $j_{\max}(\beta)$ for different systems.

    **Key observations:**
    1. All curves peak at intermediate $\beta$
    2. 2D systems have lower $j_{\max}$ than 1D
    3. C3 symmetry further reduces $j_{\max}$

    **Why the peak at $\beta \approx 0.6-0.7$?**

    The asymmetric peak (not at $\beta=0.5$) arises because:
    - Higher filling  more carriers
    - But also more cancellation
    - Optimal balance slightly above half-filling
                """),
                fig_comparison_bar
            ])
        ], justify='space-around'),

        mo.md(r"""
    ---

    ## Part B: Why 2D C3 Systems Have Lower Current

    ### The Dimensional Reduction

    In **1D**: All electrons move along the same axis  velocities add constructively.

    In **2D**: Electrons on the Fermi surface have velocities pointing in **all directions**.

    $$j_x = \int v_x(\mathbf{k}) f(\mathbf{k}) d^2k = \int |\mathbf{v}| \cos\theta \, f \, dk$$

    **The $\cos\theta$ factor is the killer!** Only the component along the field contributes.
        """),

        mo.hstack([
            fig_velocity_field,
            fig_angular_current
        ], justify='space-around'),

        mo.md(r"""
    ### Angular Averaging: The Quantitative Picture

    **For an isotropic 2D band:**
    $$\langle \cos\theta \rangle_{\text{Fermi}} = 0 \text{ (at equilibrium)}$$

    Under an applied field, the distribution shifts, but the effective velocity is reduced by $\sim \frac{1}{2}$ compared to 1D.

    **For a C3-symmetric band (like moir graphene):**

    The trigonal warping introduces additional structure:
    - Velocity magnitude varies around the Fermi surface
    - Some directions are "faster" than others
    - Net effect: **further reduction** to $\sim 35\%$ of 1D
        """),

        mo.hstack([
            fig_angle_dist,
            fig_current_contrib
        ], justify='space-around'),

    

        mo.md(r"""
    ---

    ## Summary: The Two Key Effects

    | Effect | Physics | Reduction Factor |
    |--------|---------|------------------|
    | **Filling dependence** | Balance between +v and v states | Peak at $\beta \approx 0.6-0.7$ |
    | **Angular averaging (2D)** | Only $v \cdot \hat{E}$ contributes | $\times 0.5$ |
    | **C3 symmetry** | Trigonal velocity modulation | $\times 0.7$ |

    **Combined effect for C3 2D system:**
    $$j_{\max}^{\text{2D-C3}} \approx 0.35 \times j_{\max}^{\text{1D}}$$

    ### Physical Interpretation

    1. **1D is optimal** because all electrons move along the field direction
    2. **2D suffers from geometry**  electrons scatter in all directions
    3. **C3 symmetry adds warping**  further reducing the "useful" velocity component

    This explains why observing Bloch oscillations in 2D moir systems requires:
    - Very flat bands (large $F_c$)
    - Long scattering times ($\omega_B \tau > 1$)
    - Optimal filling ($\beta \sim 0.5-0.7$)
        """)
    ])
    return (tab7_content,)


if __name__ == "__main__":
    app.run()
